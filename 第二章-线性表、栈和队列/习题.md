# 第二章 线性表、栈和队列

## 2.1 教材习题

### 2.1.1 设顺序表 a 中的数据元素递增有序，设计一个算法，将 x 插入到顺序表的适当位置，以保持该表的有序性

> **解答：** _[code 2-1-1.cpp](./src/2-1-1.cpp)_
>
> 因为是顺序表，并且递增，可用二分法查找合适位置。当有重复的数据元素时，在该位置的前或后插入元素均可
>
> ```cpp
> #include <iostream>
>
> using namespace std;
>
> template <typename T>
> class List{
>     private:
>         T *aList;               // 存储顺序表的实例
>         int maxSize;            // 顺序表的最大长度
>         int curLen;             // 顺序表的当前长度
>     public:
>         List(const int size){
>             maxSize = size;
>             aList = new T[maxSize];
>             curLen = 0;
>         }
>         ~List(){
>             delete []aList;
>         }
>         bool insert(const T value){
>             int left, right, mid;
>             left = 0;
>             right = curLen;
>             if(curLen >= maxSize){
>                 cout << "顺序表已满" << endl;
>                 return false;
>             }
>             // 若当前无元素或最后一个元素小于value, 直接加入新元素
>             if(curLen == 0 || aList[curLen-1] <= value){
>                 aList[curLen++] = value;
>                 return true;
>             }
>             // 否则用二分查找合适位置
>             while(left <= right){
>                 mid = (right - left)/2 + left;
>                 if(aList[mid] < value)
>                     left = mid + 1;
>                 else if(aList[mid] > value){
>                     if(aList[mid-1] < value)
>                         break;
>                     right = mid - 1;
>                 }
>             }
>             // mid后的所有元素后移一个位置
>             for(int i = curLen-1; i >= mid; i--)
>                 aList[i+1] = aList[i];
>             aList[mid] = value;
>             curLen ++;
>             return true;
>         }
>         void showAll(){
>             for(int i = 0; i < curLen; i++)
>                 cout << aList[i] << " ";
>             cout << endl;
>         }
> };
> ```

### 2.1.2 设$A=(a_1,...,a_m)$和$B=(b_1,..,b_n)$均为顺序表，$A'$和 $B'$分别是 $A$ 和 $B$ 中除去最大共同前缀后的子表。例如，$A=(b,e,i,j,i,n,g)，B=(b,e,i,f,a,n,g)$，则两者最大公共前缀为 $b,e,i$。此时 $A'=(j,i,n,g)，B'=(f,a,n,g)$。若 $A'=B'=$ 空表，则 $A=B$；若 $A'=$ 空表，而 $B'≠$ 空表，或者两者均不为空表，且 $A'$的首元小于 $B'$的首元，则 $A<B$；否则 $A>B$。试编写一个比较 $A、B$ 大小的算法

> **解答：** _[code 2-1-2.cpp](./src/2-1-2.cpp)_
>
> ```cpp
> // An是A[]的长度，Bn是B[]的长度
> template <typename T>
> int compare(T A[], int An, T B[], int Bn){
>     // 过滤掉公共前缀
>     int i = 0;
>     while(i < An && i < Bn && A[i] == B[i])
>             i++;
>     if(i >= An && i >= Bn)      // A,B均为空，下标i大于数组中的元素
>         return 0;
>     else if((i >= An && i < Bn) || A[i] < B[i])     // A空B不空或A’有元素小与B'首元素
>         return -1;
>     else
>         return 1;
> }
> ```

### 2.1.3 设线性表中的数据元素依值递增排序，并以单链表作为存储结构。设计一个高效的算法，删除表中所有值大于 mink 且小于 maxk 的元素，同时释放被删除结点的空间，并分析算法的时间复杂度

> **解答：** _[code 2-1-3.cpp](./src/2-1-3.cpp)_
>
> ```cpp
> #include "../headers/linear.hpp"
>
>
> template <typename T>
> class LinkList2:public LinkList<T>{
>     public:
>         bool deleteMiddleElem(int mink, int maxk);
> };
>
> template <typename T>
> bool LinkList2<T>::deleteMiddleElem(int mink, int maxk){
>     Link<T> *pre;               // 存放mink前一个结点
>     Link<T> *cur;               // 存放当前结点
>     Link<T> *tmp;               // 存放待释放结点
>     if(mink > maxk) return false;
>     pre = this->head;
>     cur = pre->next;            // cur指向第一个结点
>
>     while(cur && cur->data < maxk){
>         if(cur->data <= mink){
>             pre = cur;
>             cur = cur->next;
>         }else{
>             pre->next = cur->next;      // 跳过待删除结点
>             tmp = cur;
>             cur = cur->next;
>             delete tmp;
>         }
>     }
>     return true;
> }
> ```

### 2.1.4 假设有两个按元素值递增的有序排序的线性表 A 和 B，均以单链表作为存储结构，设计一个算法将 A 和 B 归并成一个按元素值递减有序排列的线性表 C，并要求利用原表（即表 A 和 B）的结点空间构造表 C

> **解答：** _[code 2-1-4.cpp](./src/2-1-4.cpp)_
>
> 思路：_重复元素只保存一个_
>
> - （1）先按元素递增归并，再逆置链表（或先逆置再归并）
> - （2）头插法
>
> ```cpp
> #include "../headers/linear.hpp"
>
>
> template <typename T>
> class LinkList2:public LinkList<T>{
>     public:
>         virtual ~LinkList2(){
>             Link<T> *tmp;
>             while(this->head){
>                 tmp = this->head;
>                 this->head = this->head->next;
>                 delete tmp;
>             }
>         }
>         Link<T>* getHead(){                 // 返回头节点
>             return this->head;
>         }
>         void reverseList(){                 // 逆置链表
>             Link<T> *first, *last;
>             first = this->head->next;       // 指向第一个结点
>             this->head->next = nullptr;        // 头节点的下一个节点指向null
>             while(first){
>                 last = first->next;         // 存下下一个节点
>                 first->next = this->head->next;     // 修改节点下一个节点
>                 this->head->next = first;   // 头指针指向最后逆置的节点
>                 first = last;               // 继续逆置
>             }
>         }
>         void mergeList(LinkList2<T>* LB){
>             reverseList();
>             LB->reverseList();
>             Link<T> *pa, *pb, *tmp;
>             pa = this->head->next;          // pa指向第一个节点
>             pb = LB->getHead()->next;
>             LB->getHead()->next = nullptr;  // 指向空，方便析构函数释放空间
>             this->head->next = nullptr;
>             tmp = this->head;
>
>             while(pa && pb){
>                 if(pa->data == pb->data){
>                     tmp->next = pa;
>                     tmp = pb;               // 先释放空间再重新指向链表
>                     pb = pb->next;
>                     delete tmp;
>                     tmp = pa;
>                     pa = pa->next;
>                 }
>                 else if(pa->data > pb->data){
>                     tmp->next = pa;
>                     tmp = pa;
>                     pa = pa->next;
>                 }else{
>                     tmp->next = pb;
>                     tmp = pb;
>                     pb = pb->next;
>                 }
>             }
>             if(pa)
>                 tmp->next = pa;             // 只剩原链表的节点
>             else
>                 tmp->next = pb;             // 只剩LB链表的节点
>         }
>         // 头插法，不需要逆置，每次移动头指针
>         void mergeList2(LinkList2<int> *LB){
>             Link<T> *pa = this->head->next;
>             Link<T> *pb = LB->getHead()->next;
>             Link<T> *tmp;
>
>             LB->getHead()->next = nullptr;
>             this->head->next = nullptr;
>
>             while(pa != nullptr && pb != nullptr){
>                 if(pa->data == pb->data){
>                     tmp = pb;
>                     pb = pb->next;
>                     delete tmp;
>                     tmp = pa->next;
>                     pa->next = this->head->next;
>                     this->head->next = pa;
>                     pa = tmp;
>                 }
>                 else if(pa->data <= pb->data){
>                     tmp = pa->next;
>                     pa->next = this->head->next;
>                     this->head->next = pa;
>                     pa = tmp;
>                 }else{
>                     tmp = pb->next;
>                     pb->next = this->head->next;
>                     this->head->next = pb;
>                     pb = tmp;
>                 }
>             }
>
>             while(pa != nullptr){
>                 tmp = pa->next;
>                 pa->next = this->head->next;
>                 this->head->next = pa;
>                 pa = tmp;
>             }
>             while(pb != nullptr){
>                 tmp = pb->next;
>                 pb->next = this->head->next;
>                 this->head->next = pb;
>                 pb = tmp;
>             }
>         }
> };
> ```

### 2.1.5 已知由一个链表表示的线性表中含有 3 类字符的数据元素（字母字符、数字字符和其他字符），设计一个算法将该线性表分割为 3 个循环链表，其中每个循环链表均只含一类字符

> **解答：** _[code 2-1-5.cpp](./src/2-1-5.cpp)_
>
> ```cpp
> #include <iostream>
> #include "../headers/linear.hpp"
>
>
> // 创建一个循环链表类
> // 若加入尾指针会更方便
> template <typename T>
> class LoopLink{
>     protected:
>         Link<T> *head;
>     public:
>         LoopLink(){
>             head = new Link<T>;
>             head->next = head;
>         }
>         ~LoopLink(){
>             Link<T> *tmp, *next;
>             tmp = head->next;           // 取第一个节点
>             while(tmp != head){
>                 next = tmp->next;
>                 delete tmp;
>                 tmp = next;
>             }
>             delete head;
>         }
>         bool addLink(Link<T> *l){
>             Link<T> *p = head;
>             // 找到循环链表最后一个节点
>             while(p->next != head)
>                 p = p->next;
>             l->next = head;
>             p->next = l;
>             return true;
>         }
>         bool addValue(T c){
>             Link<T> *tmp;
>             tmp = new Link<T>(c);
>             if(addLink(tmp))
>                 return true;
>             return false;
>         }
>         void showAll(){
>             using std::cout;
>             using std::endl;
>             Link<T> *tmp;
>             tmp = head->next;
>             while(tmp != head){
>                 cout << tmp->data << "  ";
>                 tmp = tmp->next;
>             }
>             cout << endl;
>         }
> };
>
> template <typename T>
> class LinkList2:public LinkList<T>{
>     public:
>         ~LinkList2(){
>             Link<T> *tmp;
>             while(this->head){
>                 tmp = this->head;
>                 this->head = this->head->next;
>                 delete tmp;
>             }
>         }
>         Link<T>* getHead(){
>             return this->head;
>         }
>         void setHead(){                         // 设置头节点下一个节点为nullptr，方便析构
>             this->head->next = nullptr;
>         }
> };
>
> void split(LinkList2<char>* L, LoopLink<char>* a, LoopLink<char>* d, LoopLink<char>* o){
>     Link<char> *tmp = L->getHead()->next;
>     L->setHead();
>     Link<char> *save;
>     while(tmp){
>         save = tmp->next;
>         if(tmp->data <= '9' && tmp->data >= '0')
>             d->addLink(tmp);
>         else if((tmp->data <= 'Z' && tmp->data >= 'A') || (tmp->data <= 'z' && tmp->data >= 'a'))
>             a->addLink(tmp);
>         else
>             o->addLink(tmp);
>         tmp = save;
>     }
> }
> ```

### 2.1.6 设计一个算法，从一个顺序表中删除第 i 个元素开始的 k 个元素

> **解答：** _[code 2-1-6.cpp](./src/2-1-6.cpp)_
>
> ```cpp
> #include "../headers/linear.hpp"
> #include <iostream>
>
>
> // 当k比较大时，默认i后面元素全部删除，若要求第i+k元素必须存在，则需要判断是否越界
> template <typename T>
> class SqList:public ArrList<T>{
>     public:
>         SqList(const int size):ArrList<T>(size){}
>         bool deleteRange(int i, int k){
>             using std::cout;
>             using std::endl;
>             if(i < 1 || i > this->curLen)
>                 cout << "删除位置不合法" << endl;
>             for(int j = i-1; j <= this->curLen-1; j++)
>                 this->aList[j] = this->aList[j+k];
>             this->curLen -= k;
>             return true;
>         }
> };
> ```

### 2.1.7 已知线性表中元素依值递增有序排列，并以单链表作为存储结构。设计一个算法，删除表中值相同的多余元素，使得操作后表中的所有元素值均不相同，同时释放被删除的结点空间

> **解答：** _[code 2.1-7.cpp](./src/2-1-7.cpp)_
>
> ```cpp
> #include "../headers/linear.hpp"
>
>
> template <typename T>
> class LinkList2:public LinkList<T>{
>     public:
>         bool removeSame(){
>             Link<T> *pre, *cur;
>             pre = this->head->next;
>             cur = pre->next;
>             while(cur){
>                 if(pre->data == cur->data){
>                     pre->next = cur->next;
>                     delete cur;
>                     cur = pre->next;
>                 }else{
>                     pre = pre->next;
>                     cur = pre->next;
>                 }
>             }
>             return true;
>         }
> };
> ```

### 2.1.8 已知两个依元素递增的有序排列的顺序表 A 和 B，且同一表中的元素值各不相同，构造一个线性表 C，其元素为 A 和 B 中元素的交集，且表 C 中的元素也依值有序递增排列。设计对 A,B,C 都是顺序表的情况的算法

> **解答：** _[code 2.1-8.cpp](./src/2-1-8.cpp)_
>
> ```cpp
> #include "../headers/linear.hpp"
>
>
> void Solution(ArrList<int>* A, ArrList<int>* B, ArrList<int>* C){
>     int lenA, lenB;
>     lenA = A->length();
>     lenB = B->length();
>
>     for(int i = 0, j = 0; i < lenA && j < lenB; ){
>         int valueA,valueB;
>         A->getValue(i, valueA);
>         B->getValue(j, valueB);
>
>         if(valueA == valueB){
>             C->append(valueA);
>             i++, j++;
>         }
>         else if(valueA > valueB)        // A大B小,j++
>             j++;
>         else
>             i++;
>     }
> }
> ```

### 2.1.9 要求同第 8 题，设计对 A、B、C 都是单链表的情况的算法

> **解答：**
>
> ```cpp
> #include "../headers/linear.hpp"
>
> void Solution(LinkList<int>* A, LinkList<int>* B, LinkList<int>* C){
>     Link<int>* tmpA;
>     Link<int>* tmpB;
>
>     tmpA = A->getFirst();          // 指向A的第一个节点
>     tmpB = B->getFirst();          // 指向B的第一个节点
>
>     while(tmpA && tmpB){
>         if(tmpA->data == tmpB->data){
>             C->append(tmpA->data);
>             tmpA = tmpA->next;
>             tmpB = tmpB->next;
>         }else if(tmpA->data > tmpB->data)
>             tmpB = tmpB->next;
>         else
>             tmpA = tmpA->next;
>     }
> }
> ```

### 2.1.10 设表达式以字符形式已存入数组 E[n]中，"#"为表达式的结束符，试设计判断表达式中括号（"("和")"）是否匹配的算法

> **解答：** _[code 2-1-10.cpp](./src/2-1-10.cpp)_
>
> ```cpp
> #include <stack>
> #include <iostream>
>
> typedef char Elem;
>
> bool isMatch(Elem *E, int length){
>     using std::stack;
>     stack<Elem> s;
>     for(int i = 0; i < length; i++){
>         if(E[i] == '(')
>             s.push(E[i]);
>         else if(E[i] == ')'){
>             // 栈为空且碰到了右括号则匹配失败
>             if(s.empty())  return false;
>             else{
>                 s.pop();
>             }
>         }
>     }
>     // 遍历完毕后栈空，那么匹配成功
>     if(s.empty()) return true;
>     return false;
> }
> ```

## 2.2 教材上机题

### 2.2.1 试设计一个非递归算法在 O(n)时间内将一个含有 n 个元素的单链表逆置，要求其辅助空间为常量

### 2.2.2 给定一个单向链表，试设计一个既节省时间又节省空间的算法来找出该链表的倒数第 m 个元素。实现这个算法，并对可能出现的特殊情况做相应的处理。自行设计链表的数据结构。（“倒数第 m 个元素”的含义：当 m=0 时，链表的最后一个元素将被返回）

### 2.2.3 设有 n 个人围坐在一个圆桌周围，现从第 s 个人开始报数，数到第 m 的人出列，然后从出列的下一个人重新开始报数，数到第 m 的人又出列，如此反复直到所有的人全部出列位置。Jpsephus 问题是：对于任意给定的 n、s、m，求出按出列次序得到的 n 个人员的序列。试在计算机上模拟 Josephus 问题的求解过程

## 2.3 教材习题（栈与队列）

### 2.3.1 如果允许在循环队列的两端都可以进行插入和删除操作。要求

**&nbsp;（1）写出循环队列的类型定义**  
**&nbsp;（2）写出“从队尾删除”和“从队头插入”的算法**

> **解答：** _[code 2-3-1.cpp](./src/2-3-1.cpp)_
>
> ```cpp
> #include <iostream>
>
> using namespace std;
>
> template <typename T>
> class LoopQueue{
>     private:
>         int mSize;                  // 存放队列的数组大小
>         int front;                  // 队首
>         int rear;                   // 队尾
>         T *qu;                      // 队列数组
>     public:
>         LoopQueue(int size){
>             mSize = size + 1;
>             qu = new T[mSize];
>             front = rear = 0;
>         }
>         ~LoopQueue(){
>             delete [] qu;
>         }
>         void clear(){               // 清空队列
>             front = rear;
>         }
>         inline bool isEmpty();      // 队列是否为空
>         inline bool isFull();       // 队列是否已满
>         bool enQueue(const T &item);// 入队
>         bool deQueue(T &item);      // 出队
>         bool deRear(T &item);       // 队尾删除
>         bool enFront(const T &item);// 队首插入
>         void showAll();             // 显示队列所有元素
> };
>
>
> template <typename T>
> bool LoopQueue<T>::isEmpty(){
>     return front == rear;
> }
>
> template <typename T>
> bool LoopQueue<T>::isFull(){
>     return (rear + 1) % mSize == front;
> }
>
> template <typename T>
> bool LoopQueue<T>::enQueue(const T &item){
>     if(isFull()){
>         cout << "队列满，不能入队" << endl;
>         return false;
>     }
>     qu[rear] = item;
>     rear = (rear + 1) % mSize;
>     return true;
> }
>
> template <typename T>
> bool LoopQueue<T>::deQueue(T &item){
>     if(isEmpty()){
>         cout << "队列空，不能出队" << endl;
>         return false;
>     }
>     item = qu[front];
>     front = (front + 1) % mSize;
>     return true;
> }
>
> template <typename T>
> bool LoopQueue<T>::deRear(T &item){
>     if(isEmpty()){
>         cout << "队列空，不能队尾出队" << endl;
>         return false;
>     }
>     item = qu[rear-1];
>     rear = (rear + mSize - 1) % mSize;
>     return true;
> }
>
> template <typename T>
> bool LoopQueue<T>::enFront(const T &item){
>     if(isFull()){
>         cout << "队列满，不能队首入队" << endl;
>         return false;
>     }
>     front = (front + mSize - 1) % mSize;
>     qu[front] = item;
>     return true;
> }
>
> template <typename T>
> void LoopQueue<T>::showAll(){
>     int tmp = front;
>     while(tmp != rear){
>         cout << qu[tmp] << " ";
>         tmp = (tmp + 1) % mSize;
>     }
>     cout << endl;
> }
> ```

### 2.3.2 如果用一个循环数组 q[0...m-1]表示队时，该队列只有一个队列头指针 front，不设队列尾指针 rear，而设置计数器 count 用以记录队列中结点的个数。试编写算法实现队列的 3 个基本运算：判空，入队，出队

> **解答：** _[code 2-3-2.cpp](./src/2-3-2.cpp)_
>
> ```cpp
> #include <iostream>
>
> using namespace std;
>
> class Queue{
>     private:
>         int *qu;
>         int front;
>         int count;
>         int msize;
>     public:
>         Queue(int size){
>             msize = size;
>             qu = new int[msize];
>             count = 0;
>             front = 0;
>         }
>         ~Queue(){
>             delete [] qu;
>         }
>         bool isEmpty(){
>             return count == 0;
>         }
>         bool enQueue(int item){
>             if(count == msize){
>                 cout << "队列满，不能入队" << endl;
>                 return false;
>             }
>             int rear;       // 待入队位置
>             rear = (front + count) % msize;
>             qu[rear] = item;
>             count++;
>             return true;
>         }
>         bool deQueue(int &item){
>             if(count == 0){
>                 cout << "队列空，不能出队" << endl;
>                 return false;
>             }
>             item = qu[front];
>             front = (front + 1) % msize;
>             count --;
>             return false;
>         }
> };
> ```

### 2.3.3 试按以下的要求把栈 S 中的元素逆置

**&nbsp;（1）使用额外的两个栈**  
**&nbsp;（2）使用额外的一个队列**  
**&nbsp;（3）使用额外的一个栈，外加一些非数组的变量**

> **解答：** _[code 2-3-3.cpp](./src/2-3-3.cpp)_
>
> ```cpp
> #include <stack>
> #include <iostream>
> #include <queue>
>
> using namespace std;
>
> // (1) 使用额外两个栈
> /*
>     原栈s，s出栈到s1，s1再出栈到s2，s2再出栈给s
> */
> void ReverseStack1(stack<int> &s){
>     stack<int> s1, s2;
>     while(!s.empty()){
>         s1.push(s.top());
>         s.pop();
>     }
>     while(!s1.empty()){
>         s2.push(s1.top());
>         s1.pop();
>     }
>     while(!s2.empty()){
>         s.push(s2.top());
>         s2.pop();
>     }
> }
>
>
> // (2) 使用额外一个队列
> /*
>    原栈s出栈到队列q，队列再出队入栈s
>    导入的队列头文件出队的元素是出队函数的参数(引用)，故需要临时变量
>    若队列出队有返回值，则不需要临时变量
> */
> void ReverseStack2(stack<int> &s){
>     queue<int> q;
>     while(!s.empty()){
>         q.push(s.top());
>         s.pop();
>     }
>     while(!q.empty()){
>         s.push(q.front());
>         q.pop();
>     }
> }
>
>
> // (3) 使用额外一个栈，加一些非数组变量
> /*
>    用临时变量存储栈顶元素，剩下元素原栈s弹出并入栈s2，最后将临时变量入栈，
>    即完成一次逆置，循环执行（每次出栈次数减一）
> */
> void ReverseStack3(stack<int> &s){
>     stack<int> s2;
>     int tmp;
>     for(auto count = s.size(); count > 0; count--){
>         tmp = s.top();
>         s.pop();
>         for(int i = 1; i < count; i++){
>             s2.push(s.top());
>             s.pop();
>         }
>         s.push(tmp);
>         while(!s2.empty()){
>             s.push(s2.top());
>             s2.pop();
>         }
>     }
> }
> ```

### 2.3.4 试给出用栈所定义的队列

> **解答：** _[code 2-3-4.cpp](./src/2-3-4.cpp)_
>
> 用栈定义队列需要两个栈，一个作为入队使用，一个作为出队使用。
>
> ```cpp
> #include <stack>
> #include <iostream>
>
>
> template <typename T>
> class QueueUsingStack{
>     private:
>         std::stack<T> s1;           // 入队使用
>         std::stack<T> s2;           // 出队使用
>     public:
>         QueueUsingStack(){}
>         ~QueueUsingStack(){}
>         bool isEmpty();
>         bool enQueue(const T &item);
>         bool deQueue(T &item);
> };
>
> template <typename T>
> bool QueueUsingStack<T>::isEmpty(){
>     if(s1.empty() && s2.empty())
>         return true;
>     return false;
> }
>
> template <typename T>
> bool QueueUsingStack<T>::enQueue(const T &item){
>     s1.push(item);
>     return true;
> }
>
> template <typename T>
> bool QueueUsingStack<T>::deQueue(T &item){
>     using std::cout;
>     using std::endl;
>     if(isEmpty()){
>         cout << "栈空，不能出栈" << endl;
>         return false;
>     }
>     if(s2.empty()){
>         while(!s1.empty()){
>             s2.push(s1.top());
>             s1.pop();
>         }
>     }
>     item = s2.top();
>     s2.pop();
>     return true;
> }
> ```

### 2.3.5 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针，请写出相应的入队列和出队列算法

> **解答：** _[code 2-3-5.cpp](./src/2-3-5.cpp)_
>
> ```cpp
> #include <iostream>
> #include "../headers/linear.hpp"
>
> using namespace std;
>
> template <typename T>
> class LoopLink{
>     private:
>         Link<T> *head, *rear;
>         int len;
>     public:
>         LoopLink();
>         ~LoopLink();
>         bool isEmpty();
>         bool enQueue(const T &item);
>         bool deQueue(T &item);
>         void showAll();
> };
>
>
> template <typename T>
> LoopLink<T>::LoopLink(){
>     head = new Link<T>();
>     head->next = head;
>     rear = head;
>     len = 0;
> }
>
> template <typename T>
> LoopLink<T>::~LoopLink(){
>     rear->next = nullptr;
>     Link<T> *tmp;
>     while(head){
>         tmp = head;
>         head = head->next;
>         delete tmp;
>     }
> }
>
> template <typename T>
> bool LoopLink<T>::isEmpty(){
>     return head == rear;
> }
>
> template <typename T>
> bool LoopLink<T>::enQueue(const T &item){
>     Link<T> *tmp = new Link<T>(item);
>     if(head == rear){
>         head->next = tmp;
>         tmp->next = head;
>         rear = tmp;
>         return true;
>     }
>     rear->next = tmp;
>     rear = tmp;
>     tmp->next = head;
>     len++;
>     return true;
> }
>
> template <typename T>
> bool LoopLink<T>::deQueue(T &item){
>     if(isEmpty()){
>         cout << "队列空，不能出队" << endl;
>         return false;
>     }
>     Link<T> *tmp;
>     tmp = head->next;
>     head->next = tmp->next;
>     if(tmp == rear)             // 只有一个节点
>         rear = head;
>     item = tmp->data;
>     len--;
>     delete tmp;
>     return true;
> }
>
> template <typename T>
> void LoopLink<T>::showAll(){
>     Link<T> *tmp;
>     tmp = head->next;
>     while(tmp != head){
>         cout << tmp->data << " ";
>         tmp = tmp->next;
>     }
>     cout << endl;
> }
> ```

### 2.3.6 试在一个长度为 n 的数组中实现两个栈，使得二者在元素的总数目为 n 之前都不溢出，并且保证 push 和 pop 的操作时间代价为 O(1)

> **解答：** _[code 2-3-6.cpp](./src/2-3-6.cpp)_
>
> 对于双向进行存储的栈，可以让两个栈的底分别位于作为存储的向量的始端和末端，而开始和末尾分别作为栈的初始栈顶，当栈顶相遇时，产生溢出异常。  
> 一个长为 n 数组实现两个栈，可将两个栈的栈顶分别设为-1，n。入栈时两端向中间添加元素。
>
> ```cpp
> #include <iostream>
> using namespace std;
>
> class Queue{
>     private:
>         int lfirst;             // 左边数组标志
>         int rfirst;             // 右边数组标志
>         int *qu;
>         int size;               // 数组最大长度
>     public:
>         Queue(int num);
>         ~Queue();
>         inline bool isEmpty();
>         inline bool isFull();   // 是否已满
>         bool lpush(int item);   // 左边入栈
>         bool rpush(int item);   // 右边入栈
>         bool lpop(int &item);   // 左边出栈
>         bool rpop(int &item);   // 右边出栈
> };
>
> Queue::Queue(int num){
>     size = num;
>     qu = new int[size];
>     lfirst = -1;
>     rfirst = size;
> }
>
> Queue::~Queue(){
>     delete [] qu;
> }
>
> bool Queue::isEmpty(){
>     return (lfirst == -1 && rfirst == size);
> }
>
> bool Queue::isFull(){
>     return lfirst + 1 == rfirst;
> }
>
> bool Queue::lpush(int item){
>     if(isFull()){
>         cout << "栈满，不能入栈" << endl;
>         return false;
>     }
>     qu[++lfirst] = item;
>     return true;
> }
>
> bool Queue::rpush(int item){
>     if(isFull()){
>         cout << "栈满，不能入栈" << endl;
>         return false;
>     }
>     qu[--rfirst] = item;
>     return true;
> }
>
> bool Queue::lpop(int &item){
>     if(isEmpty()){
>         cout << "栈空，不能出栈" << endl;
>         return false;
>     }
>     item = qu[lfirst--];
>     return true;
> }
>
> bool Queue::rpop(int &item){
>     if(isEmpty()){
>         cout << "栈空，不能出栈" << endl;
>         return false;
>     }
>     item = qu[rfirst++];
>     return true;
> }
> ```

### 2.3.7 编号为 1、2、3、4 的 4 辆列车，顺序开进一个栈式结构的站台，请问开出车站的顺序有多少种可能

> **解答：**
>
> 14 种可能
>
> 思路：先进站的车可以先开，也可以后开。有一种情况不可能，即编号大的车开出后，编号比其小的车只能由大到小依次开出（中间可以插入编号更大的车，但此车后面编号小的车也要遵守此规则）。例如 $312$ 的开出顺序是不可能的，$231$ 是可能的。全排列$A_{4}^{4}=24$种出法，但 $4$ 开头的只能有一种：$4321$，所以少了$A_{3}^{3}-1=5$种。$3$ 开头时，必须先 $2$ 后$1$，先 $1$ 后 $2$ 的情况有：$3124、3142、3412$，所以少了 $3$ 种。$1$ 或 $2$ 开头时，后面的车如果是 $4$，则最后两辆必须是 $3、2$ 或 $3、1$，所以又少了两种 $1423、2413$。一共少了 $5+3+2=10$ 种，最后有 $24-10=14$ 种开出方法。
>
> 下面用+表示进站、-表示出战：
>
> ```txt
> 1234: 1+ 1- 2+ 2- 3+ 3- 4+ 4-
> 1243: 1+ 1- 2+ 2- 3+ 4+ 4- 3-
> 1324: 1+ 1- 2+ 3+ 3- 2- 4+ 4-
> 1342: 1+ 1- 2+ 3+ 3- 4+ 4- 2-
> 1432: 1+ 1- 2+ 3+ 4+ 4- 3- 2-
> 2134: 1+ 2+ 2- 1- 3+ 3- 4+ 4-
> 2143: 1+ 2+ 2- 1- 3+ 4+ 4- 3-
> 2314: 1+ 2+ 2- 3+ 3- 1- 4+ 4-
> 2341: 1+ 2+ 2- 3+ 3- 4+ 4- 1-
> 2431: 1+ 2+ 2- 3+ 4+ 4- 3- 1-
> 3214: 1+ 2+ 3+ 3- 2- 1- 4+ 4-
> 3241: 1+ 2+ 3+ 3- 2- 4+ 4- 1-
> 3421: 1+ 2+ 3+ 3- 4+ 4- 2- 1-
> 4321: 1+ 2+ 3+ 4+ 4- 3- 2- 1-
> ```

### 2.3.8 证明：从初始输入序列 $1,2,...,n$可以利用一个栈得到输出序列$p_1,p_2,...,p_n,$($p_1,p_2,...,p_n$是$1,2,...,n$的一种排列)的充分必要条件是：不存在下标$i,j,k,$满足$i<j<k$的同时$p_j<p_k<p_i$

> **解答：**
>
> **[充分性]** 归纳法
>
> (1) 当 $n=3$ 时，满足约束条件（不存在下标 $i,j,k$，满足 $i< j< k$ 同时$P_j<P_k<P_i$）的序列有 $5$ 种：$123、132、213、231、321$，都可以用栈得到。  
> (2) 假设元素个数为 $n-1$ 时成立，当元素个数为 $n$ 时同样成立：序列$P_1,P_2,...,P_n$中，设$P_i=n$。则$P_1,P_2,...,P_{i-1},P_{i+1},...,P_n$是由$1,2,...,n-1$组成的排列，且满足约束条件，根据该假设可以利用栈得到。设$P_j=n-1$，则：
>
> - (a) $j<=i-1$时：说明 $n-1$ 在弹出$P_{i-1}$之前已经压入栈中，因此当$P_{i-1}$从栈中弹出之后，将 $n$ 压入栈并立即弹出，之后按照$P_{i+1},...,P_n$原先的顺序弹栈，即可获得$P_1,P_2,...,P_n$
> - (b) $j>=i+1$时：首先证明当$j>=i+1$时，$j$一定等于$i+1$。利用反证法：若$j>i+1$，则在$n(P_i),n-1(P_j)$之间至少有一个数，且这个数小于 $n-1$ 它的下标大于 $i$ 小于 $j$，这种情况与条件矛盾。因此 $j=i+1$。这说明序列$P_1,...P_{i-1},P_{i+1},...P_n$的生成过程中，弹出$P_{i-1}$之后，将会压入 $n—1$(即$P_{i+1}$)并立即弹出。可以作出修改如下：在压入$n-1$之后再压入 $n$，并立即弹出 $n$ 和 $n-1$，之后按照$P_{i+2},...,P_n$的顺序弹栈，即可获得$P_1,P_2,...,P_n$。
>
> $因此P_2,P_2,...,P_n可以用栈得到，命题在k=n时同样成立$
>
> **[必要性]** 反证法
>
> 如果存在$P_j< P_k < P_i$，则$P_k$应比$P_j$后压入，但此时取出的顺序则为$P_j$在$P_k$之前，显然与栈的 _FILO_ 原则矛盾，所以同样不存在下标 $i,j,k$，满足$i< j < k 同时 P_j< P_k < P_i$。

### 2.3.9 试利用栈计算后缀表达式 12 8 9 \* + , 并明确写出每个步骤以及每个步骤的状态

> **解答：**
>
> 对于后缀表达式求值，从左到右扫描，遇到操作数压栈，遇到操作符出栈两次，计算后压栈。
>
> | 1    | 2    | 3    | 4      | 5     |
> | ---- | ---- | ---- | ------ | ----- |
> | 入栈 | 入栈 | 入栈 | 计算\* | 计算+ |
> |      |      | 9    |        |       |
> |      | 8    | 8    | 72     |       |
> | 12   | 12   | 12   | 12     | 84    |

### 2.3.10 试利用栈计算中缀表达式 a*(b*c-d)+e 转换成后缀表达式。试写出每个步骤以及每个步骤的栈的状态

> **解答：**
>
> 转换方法可见教材 p54  
> &emsp;a  
> &emsp;a b  
> &emsp;a b c \*  
> &emsp;a b c \* d -  
> &emsp;a b c \* d - \*  
> &emsp;a b c \* d - \* e +
> | 1 | 2 | 3 | 4 | 5 | 6 |
> | --- | --- | --- | --- | --- | --- |
> | | | \* | - | | |
> | | ( | ( | ( | | |
> | \* | \* | \* | \* | \* | + |

### 2.3.11 试写出一个按照下面定义计算整数 $n$ 和 $m$ 的最大共因此 $GCD(n,m)$的递归算法

$$
GCD(n,m)
\left\{\begin{matrix}
m & \text(当m\leqslant n且n\%m = 0) \\
GCD(m,n) & 当n<m\\
GCD(m,n\%m) & 否则
\end{matrix}\right.
$$

> **解答：** _[code 2-3-11.cpp](./src/2-3-11.cpp)_
>
> ```cpp
> int GCD(int n, int m){
>     if(m <= n && n % m == 0)
>         return m;
>     else if(n < m)
>         return GCD(m, n);
>     else
>         return GCD(m, n % m);
> }
> ```

### 2.3.12 试写出计算下面序列的前 $n$ 项和的递归算法，并给出相应的使用栈的非递归算法

$$
1+\frac{1}{2}-\frac{1}{3}+\frac{1}{4}-\frac{1}{5}...
$$

> **解答：** _[code 2-3-12.cpp](./src/2-3-12.cpp)_
>
> ```cpp
> #include <iostream>
> #include <stack>
> using namespace std;
>
>
> double Recusion(int n){
>     if(n == 1)
>         return 1.0;
>     else
>         return ((n % 2) ? -1 : 1) * 1.0 / n + Recusion(n-1);
> }
>
> // 循环
> double NotRecusion(int n){
>     if(n == 1)
>         return 1.0;
>     stack<double> s = stack<double>();
>     s.push(1.0);
>     for(int i = 2; i <= n; i++){
>         double sign;
>         sign = (i % 2) ? -1.0 : 1.0;
>         double tmp;
>         tmp = s.top();
>         s.pop();
>         s.push(sign/i + tmp);
>     }
>     return s.top();
> }
>
> // 栈非递归
> double StackNotRecusion(int n){
>     stack<double> s;
>     while(n != 1){
>         double tmp = 1.0/n;
>         if(n % 2 == 1)
>             tmp = -tmp;
>         s.push(tmp);
>         n--;
>     }
>     s.push(1);
>     double ret = 0;
>     while(!s.empty()){
>         ret += s.top();
>         s.pop();
>     }
>     return ret;
> }
> ```

## 2.4 上机题（栈与队列）

### 2.4.1 利用两个栈 S1 和 S2 来模拟一个队列时，如何用栈的运算来实现该队列的运算

**&nbsp;（1）enqueue: 插入一个元素**  
**&nbsp;（2）dequeue: 删除一个元素**  
**&nbsp;（3）queue_empty: 判定队列为空**

### 2.4.2 双端队列 deque 是一种插入和删除操作在线性表的两端进行的数据结构，试给出利用数组实现 deque 两端的插入和删除、删除操作，要求这 4 个操作的时间代价均为常数

### 2.4.3 试利用非数组变量，按下述条件各设计一个相应的算法以使队列中的元素有序

**&nbsp;（1）使用两个辅助的队列**  
**&nbsp;（2）使用一个辅助的队列**

### 2.4.4 试按下述条件各设计一个算法把栈 S1 中的元素转移到栈 S2 中，并保持栈中元素的原来顺序

**&nbsp;（1）使用一个辅助栈**  
**&nbsp;（2）只使用一些辅助的非数组变量**

### 2.4.5 _Fibonacci_ 序列 $0,1,1,2,3,5,8,13,...$，其中每个元素都是前两个元素之和，可递归定义为下述公式。试设计一个计算 $fib(n)$的递归过程，并利用栈来模拟递归调用，将递归过程改写成一个非递归过程

$$
fib(n)
\left\{\begin{matrix}
n & n=0,1\\
fib(n-1) + fib(n-1) & n≥2
\end{matrix}\right.
$$

### 2.4.6 已知 _Ackermann_ 函数定义如下

$$
Ack(m,n) =
\left\{\begin{matrix}
 & n+1 & \text(当m = 0时)\\
 & Ack(m-1,1) & \text(当m \neq 0,n=0时) \\
 & Ack(m-1,Ack(m,n-1)) & \text(当m \neq 0, n \neq 0时)
\end{matrix}\right.
$$

**&nbsp;（1）写出 $Ack(2,1)$的计算过程。**  
**&nbsp;（2）写出计算 $Ack(m,n)$的非递归算法。**

> **解答：**
>
> （1）解：
>
> $$
> \begin{aligned}
> Ack(2,1) &= Ack(1,Ack(2,0)) \\
>          &= Ack(1,Ack(1,1)) \\
>          &= Ack(1,Ack(0,Ack(1,0))) \\
>          &= Ack(1,Ack(0,Ack(0,1))) \\
>          &= Ack(1,Ack(0,2)) \\
>          &= Ack(1,3) \\
>          &= Ack(0,Ack(1,2)) \\
>          &= Ack(0,Ack(0,Ack(1,1))) \\
>          &= Ack(0,Ack(0,Ack(0,Ack(1,0)))) \\
>          &= Ack(0,Ack(0,Ack(0,Ack(0,1)))) \\
>          &= Ack(0,Ack(0,Ack(0,2))) \\
>          &= Ack(0,Ack(0,3)) \\
>          &= Ack(0,4) \\
>          &= 5
> \end{aligned}
> $$

## 2.5《学习指导》教材习题解答

### 2.5.1 设计一个算法，求单链表 X 中，内容为 a 的结点的地址

> **解答：** _[code 2-5-1.cpp](./src/2-5-1.cpp)_
>
> 需考虑内容为 a 的地址可能有多个，由于链表中内容为 a 的结点数目不确定，可以选择用一个新链表来存放找到的结点地址。
>
> ```cpp
> #include "../headers/linear.hpp"            // 导入链表头文件
> #include <iostream>
>
>
> using namespace std;
>
> template <typename T>
> class ListNode{                             // 地址链表节点,不能使用原链表的节点，不然会破环原链表
>     public:
>         Link<T>* L;                         // 指向单链表节点的指针
>         ListNode<T>* next;                  // 指向下一个地址链表节点的指针
> };
>
> template <typename T>
> class LinkAddr{                             // 存放地址的链表
>     public:
>         ListNode<T> *head;                  // 地址链表头指针
>         LinkAddr(){
>             head = new ListNode<T>;
>             head->next = nullptr;
>         };
>         ~LinkAddr(){
>             ListNode<T> *tmp;
>             while(head){
>                 tmp = head;
>                 head = head->next;
>                 delete tmp;
>                 tmp = head;
>             }
>         }
>         void find(T a, LinkList<T>* p);     // 找到值为a的节点,并添加到链表
>         void showAll();                     // 显示所有元素
> };
>
> template <typename T>
> void LinkAddr<T>::find(T a, LinkList<T>* p){
>     Link<T> *tmp = p->getFirst();
>     while(tmp != nullptr){
>         if(tmp->data == a){
>             ListNode<T> *q = new ListNode<T>;
>             q->L = tmp;
>             q->next = head->next;
>             head->next = q;
>         }
>         tmp = tmp->next;
>     }
> }
>
> template <typename T>
> void LinkAddr<T>::showAll(){
>     ListNode<T> *tmp = head->next;
>     while(tmp != nullptr){
>         cout << tmp->L << "  ";
>         cout << (tmp->L)->data << endl;
>         tmp = tmp->next;
>     }
> }
> ```

### 2.5.2 设计一个算法，在单链表 X 中内容为 a 的结点前插入一个内容为 b 的结点

> **解答：** _[code 2-5-2.cpp](./src/2-5-2.cpp)_
>
> 需考虑存在多个内容为 a 的结点，遍历链表，在每个这样的节点前插入新结点
>
> ```cpp
> #include <iostream>
> #include "../headers/linear.hpp"
>
>
> template <typename T>
> class NewLink:public LinkList<T>{
>     public:
>         void insert(T value1, T value2){
>             using namespace std;
>             Link<T> *tmp = this->head;
>             int count;
>             while(tmp && tmp->next){
>                 if(tmp->next->data == value1){
>                     Link<T> *p = new Link<T>(value2);
>                     p->next = tmp->next;
>                     tmp->next = p;
>                     tmp = p;        // 因加入一个结点，需要指向该结点，才能指向下一个为访问结点
>                     count++;
>                 }
>                 tmp = tmp->next;
>             }
>             if(count == 0)
>                 cout << "No such an element" << endl;
>         }
> };
> ```

### 2.5.3 写出将单链表置逆的算法，即由单链表 A 产生单链表 Z，使得 A 的最后一个元素的是 Z 的第一个元素，依此类推。要求 Z 仍占用 A 所占用的存储单元，并且尽可能地减少使用附加单元

> **解答：** _[code 2-5-3.cpp](./src/2-5-3.cpp)_
>
> 用 trail,middle,head 指针指向相邻地 3 个元素，并一次往后挪，每次循环中，把原链表地两个方向改过来，即置逆过来。这样一来，如果把 head 指针看成链表自己地成员变量，只需要两个额外的指针。
>
> ```cpp
> #include "../headers/linear.hpp"
>
>
> template <typename T>
> class NewLink:public LinkList<T>{
>     public:
>         void invert();                      // 置逆方法
> };
>
> template <typename T>
> void NewLink<T>::invert(){
>     Link<T> *first, *last;
>     first = this->head->next;               // first为第一个节点
>     this->head->next = nullptr;
>     while(first){
>         last = first->next;
>         first->next = this->head->next;
>         this->head->next = first;
>         first = last;
>     }
> }
> ```

### 2.5.4 设计一个算法，一个双链表 X，是将指针边里 F 指向的结点插入到指针边里 P 指向的结点之前。请画图表示插入前后双链表的变化情况

> **解答：** _[code 2-5-4.cpp](./src/2-5-4.cpp)_
>
> ```cpp
> typedef int Elem;
> typedef struct DbListNode* DbList;
>
> // 双链表节点
> struct DbListNode{
>  Elem data;              // 数字域
>  DbList rlink;           // 右(后)指针
>  DbList llink;           // 左(前)指针
> };
>
> // 双链表结构
> struct List{
>  DbList first, last;
> };
>
>
> void Insert(DbList F, DbList P, List *X){
>  // 先判断P是否是头节点
>  if(P == X->first){
>      F->rlink = P;
>      P->llink = F;
>      X->first = F;
>  }else{
>      F->rlink = P;
>      F->llink = P->llink;    // F左边的指针指向P左边的指针
>      P->llink->rlink = F;    // P左边节点的右指针指向F
>      P->llink = F;
>  }
> }
> ```
>
> <div align=center><img src="./images/2-2-4.jpg" alt="2-2-4" height=600 width=60% /></div>

### 2.5.5 设计一个算法，求循环链表中结点的个数

> **解答：** _[code 2-5-5.cpp](./src/2-5-5.cpp)_
>
> 判断已经边里整个链表环的方法：使用一个指针变量 link 从链表首元素向后遍历整个链表，直到 link=first 时，说明该结点即尾结点
>
> ```cpp
> #include "../headers/linear.hpp"
> #include <iostream>
>
> template <typename T>
> class LoopLink{
>     protected:
>         Link<T> *head;
>     public:
>         LoopLink(){
>             head = new Link<T>;
>             head->next = head;
>         }
>         ~LoopLink(){
>             Link<T> *tmp, *next;
>             tmp = head->next;
>             while(tmp != head){
>                 next = tmp->next;
>                 delete tmp;
>                 tmp = next;
>             }
>             delete head;
>         }
>         bool addValue(T v){
>             Link<T> *tmp;
>             tmp = new Link<T>(v);
>             // 找最后一个节点
>             Link<T> *last = head;
>             while(last->next != head)
>                 last = last->next;
>             tmp->next = last->next;
>             last->next = tmp;
>             return true;
>         }
>         int length(){
>             Link<T> *tmp;
>             tmp = head;
>             int count = 0;
>             while(tmp->next != head){
>                 tmp = tmp->next;
>                 count ++;
>             }
>             return count;
>         }
> };
> ```

### 2.5.6 设计一个算法，删除循环表中的第一个结点

> **解答：** _[code 2-5-6.cpp](./src/2-5-6.cpp)_
>
> - 头结点不是第一个结点，要删除的节点是头节点之后的一个节点（这里我认为是若是用 new 申请的空间，那么头节点的 next 即为第一个节点，若不是，那么 first 指向的就是第一个节点）
> - 需要考虑特殊情况，如空链表、只有一个节点情况等。
>
> ```cpp
> #include <iostream>
>
> typedef int ELEM;
> typedef struct Node* ListNode;
>
> struct Node{
>    ELEM data;
>     ListNode next;
>     ListNode pre;
> };
>
> // 循环链表结构，假设用new申请头节点空间
> typedef struct {
>     ListNode first;
>     ListNode last;
> }CLL;
>
>
> // 考虑循环单链表
> void deleteFirstNode1(CLL *pCLL){
>     using namespace std;
>     ListNode tmp;
>     if(pCLL->first == pCLL->last){              // 循环链表为空
>         cout << "The List is NULL, no fist node" << endl;
>         return;
>     }else if(pCLL->first->next == pCLL->last){  // 只有一个节点时
>         tmp = pCLL->first->next;
>         pCLL->first->next = tmp->next;
>         pCLL->last = pCLL->first;
>     }else{                                      // 正常情况
>         tmp = pCLL->first->next;
>         pCLL->first->next = tmp->next;
>     }
>     delete tmp;
> }
>
> // 考虑循环双链表
> void deleteFirstNode2(CLL *pCLL){
>     using namespace std;
>     ListNode tmp;
>     if(pCLL->first == pCLL->last){
>         cout << "The List is NULL, no first node" << endl;
>         return;
>     }else if(pCLL->first->next == pCLL->last){
>         tmp = pCLL->first->next;
>         pCLL->last = pCLL->first;
>         pCLL->first->next = pCLL->first;
>         pCLL->first->pre = pCLL->first;
>     }else{
>         tmp = pCLL->first->next;
>         pCLL->first->next = tmp->next;
>         tmp->next->pre = pCLL->first;
>     }
>     delete tmp;
> }
> ```

### 2.5.7 设计一个算法，删除向量中第 i 个元素

> **解答：** _[code 2-5-7.cpp](./src/2-5-7.cpp)_
>
> 向量不是向量表，可以理解为是一维数组
>
> ```cpp
> #include <cassert>
> #include "../headers/linear.hpp"
>
> template <typename T>
> class AList:public ArrList<T>{
>     public:
>         AList(const int size):ArrList<T>(size){}
>         T remove(int ith){
>             assert((this->curLen != 0) && (ith >= 0) && (ith < this->curLen));    // 必须存在一个可删除元素
>             T tmp = this->aList[ith];
>             for(int i = ith; i < this->curLen-1; i++){
>                 // 向前移动
>                 this->aList[i] = this->aList[i+1];
>             }
>             this->curLen--;
>             return tmp;
>         }
> };
> ```

### 2.5.8 [教材习题（栈与队列）2.3.7](#237-编号为-1234-的-4-辆列车顺序开进一个栈式结构的站台请问开出车站的顺序有多少种可能)

### 2.5.9 [教材习题（栈与队列）2.3.6](#236-试在一个长度为-n-的数组中实现两个栈使得二者在元素的总数目为-n-之前都不溢出并且保证-push-和-pop-的操作时间代价为-o1)

### 2.5.10 对于环状的队列，写出计算队列元素个数的程序

> **解答：**
>
> 顺序队列和链式队列见 _[队列.cpp](./代码/队列.cpp)_
>
> ```cpp
> // 1. 顺序队列
> int ArrQueue::length(){
>     int len;
>     if(isEmpty())
>         len = 0;
>     else if(front <= rear)
>         len = rear - front;
>     else
>         len = mSize + rear - front;
>     return len;
> }
>
> // 2. 链式队列
> int LinkQueue::length(){
>     int len = 0;
>     for(Link<T> *tmp = front; tmp != rear; tmp = tmp->next)
>             len++;
>     return len;
> }
> ```

### 2.5.11 [教材习题（栈与队列）2.3.8](#238-证明从初始输入序列-12n可以利用一个栈得到输出序列p_1p_2p_np_1p_2p_n是12n的一种排列的充分必要条件是不存在下标ijk满足ijk的同时p_jp_kp_i)

### 2.5.12 现有中缀表达式$E=((100-4)/3+3*(36-7))*2$，请写出与 $E$ 等价的后缀表达式

> **解答：**
>
> 中缀表达式的二叉树图如下：
>
> <div align=center><img src="./images/2-2-12.jpg" alt="2-2-12" height=170 width=40% /></div>
>
> 其后缀表达式等价于后序遍历：100 4 -3 / 3 36 7 - \_ + 2 \_

### 2.5.13 _Fibonacci_ 序列为 $0,1,1,2,3,5,8,13,21,34......$其中每个元素是前两个元素之和，可递归定义为$fib(n)=fib(n-1)+fib(n-2)$;请设计一个计算$fib(n)$的递归过程，并利用栈来模拟递归调用，将递归过程改成一个非递归过程

> **解答：** _[code 2-5-13.cpp](./src/2-5-13.cpp)_
>
> 这里$fib(0)=0;fib(1)=1$
>
> 利用栈模拟递归的过程如图：
>
> <div align=center><img src="./images/2-2-13.jpg" alt="2-2-13" height=600 width=60% /></div>
>
> ```cpp
> #include <stack>
>
>
> // 递归实现
> int fib1(int n){
>     if(n > 1)
>         return fib1(n-1) + fib1(n-2);
>     else if(n == 1)
>         return 1;
>     else return 0;
> }
>
> // 非递归栈实现
> int fib2(int n){
>     if(n == 0)
>         return 0;
>     else if(n == 1)
>         return 1;
>     else{
>         std::stack<int> st;
>         // 除了f(0),f(1)压栈0,1以外，其余压栈为-1
>         while(n > 1){
>             st.push(-1);
>             n--;
>         }
>         st.push(1); // f(1);
>         st.push(0);
>         // 出栈两个求和以及一个待求的数，压栈求和以及第二个出栈的数
>         // 如求f(2)，弹出0,1以及一个-1，压栈0+1,1
>         int tmp1, tmp2;
>         while(st.size() > 2){
>             tmp1 = st.top();
>             st.pop();
>             tmp2 = st.top();
>             st.pop();
>             st.pop();       // 弹出一个-1，即待求数的位置
>             st.push(tmp1 + tmp2);
>             st.push(tmp2);
>         }
>         // 最后剩两个数，栈底的数即为所求的结果
>         st.pop();
>         return st.top();
>     }
> }
>
> // 非递归的循环迭代法
> int fib3(int n){
>     if(n < 0)
>         return -1;
>     if(n <= 1)
>         return n;
>     int a = 0, b = 1, c;
>     for(int i = 1; i < n; i++){
>         c = a + b;
>         a = b;
>         b = c;
>     }
>     return b;
> }
> ```

### 2.5.14 用一个栈来模拟表达式的转换过程，中缀表达式($E=((100-4)/3+3*(36-7))*2$)在转成后缀表达式的过程中，栈内容的变化图

> **解答：** _[code 2-5-14.cpp](./src/2-5-14.cpp)_
>
> 要求画出中缀到后缀的转换过程中栈内容的变化，而不描述计算表达式值的过程中栈内容的变化。
>
> ```cpp
> #include <stack>
> #include <cstring>
> #include <iostream>
> using namespace std;
>
>
> class MidToPost{
>     private:
>         int priority(char op);              // 返回操作符优先级
>         bool isDigit(char num);             // 判断时候为数字
>         bool isOperator(char op);           // 判断是否为操作符
>     public:
>         string mid;
>     public:
>         MidToPost(){};
>         MidToPost(string str){
>             mid = str;
>         }
>         string transfer();                  // 转换成后缀表达式
> };
>
>
> bool MidToPost::isDigit(char num){
>     if(num >= 48 && num <= 57)
>         return true;
>     else if(num == '.')
>         return true;
>     return false;
> }
>
> int MidToPost::priority(char op){
>     switch(op){
>         case '*':
>         case '/':
>             return 3;
>         case '+':
>         case '-':
>             return 2;
>         case '(':
>             return 1;
>         default:
>             return 0;
>     }
> }
>
> bool MidToPost::isOperator(char op){
>     switch(op){
>         case '+':
>         case '-':
>         case '*':
>         case '/':
>             return true;
>         default:
>             return false;
>     }
> }
>
> string MidToPost::transfer(){
>     string post = "";
>     char top;                                   // 存储栈顶元素
>     stack<char> sta = stack<char>();
>     sta.push(';');                              // 栈底标志元素
>     for(auto i = 0; i < mid.size(); i++){
>         char tmp = mid[i];
>         if(tmp == '(')
>             sta.push(tmp);                      // 左括号入栈
>         else if(isDigit(tmp)){                  // 如果是数字或'.'则存入post
>             post += tmp;
>             while(isDigit((tmp = mid[++i])))
>                 post += tmp;
>             i--;                                // 已经不是数字了，返回上一个位置
>             post += " ";
>         }
>         else if(tmp == ')'){                    // 遇到右括号出栈，直到遇到左括号为止
>             top = sta.top();
>             sta.pop();
>             while(top != '('){
>                 post += top;
>                 post += " ";
>                 top = sta.top();
>                 sta.pop();
>             }
>         }
>         else if(isOperator(tmp)){               // 如果是操作符
>             char top = sta.top();
>             sta.pop();
>             while(priority(top) >= priority(tmp)){
>                 post += top;
>                 post += " ";
>                 top = sta.top();
>                 sta.pop();
>             }
>             sta.push(top);                      // 当tmp优先级更大时
>             sta.push(tmp);
>         }
>     }
>     // 弹出栈所有元素直至栈底标志
>     top = sta.top();
>     while(top != ';'){
>         sta.pop();
>         post += top;
>         post += " ";
>         top = sta.top();
>     }
>     return post;
> }
> ```
>
> 栈内容变化如下：
>
> | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  |
> | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
> |     |     |     |     |     |     |     |     |     | -   |     |     |
> |     |     |     |     |     |     |     |     | (   | (   |     |     |
> |     |     |     | -   |     |     |     | \*  | \*  | \*  | \*  |     |
> |     |     | (   | (   |     | /   | +   | +   | +   | +   | +   |     |
> |     | (   | (   | (   | (   | (   | (   | (   | (   | (   | (   | \*  |
> | ;   | ;   | ;   | ;   | ;   | ;   | ;   | ;   | ;   | ;   | ;   | ;   |

### 2.5.15 用一个栈来模拟一个较为复杂的后缀表达式的求值过程，画出$E=((100-4)/3+3*(36-7))*2$所得到的后缀表达式求值过程中栈内容变化图

> **解答：**
>
> 思路：
>
> 1. 遇到一个操作数时，压入栈顶
> 2. 遇到一个运算符时，从栈中两次取出栈顶元素，按照运算符对两个操作数进行计算，然后计算结果压入栈顶
>
> <div align=center><img src="./images/2-2-15.jpg" alt="2-2-15" height=300 width=60%/></div>

### 2.5.16 请解决以下问题

**&nbsp;（1）设计一个计算前缀表达式的算法**  
**&nbsp;（2）设计一个将中缀表达式转换成前缀表达式的算法。假设中缀表达式以"@"结束，而前缀表达式以"@"开始**

> **解答：**
>
> (1) 利用一个栈，有两种解法
>
> - 方法一：从右向左扫描
>   1. 若遇到操作数压入栈中
>   2. 若遇到操作符，此时若栈中元素少于 2 个(操作数)则表明出错，退出。其他情况下，从栈中弹出两个元素进行计算后将结果放回栈中。
>   3. 扫描结束时，如果栈中只含唯一元素，则将栈中数据作为结果输出，否则表明前缀表达式有错。
> - 方法二：从左向右扫描
>   1. 若遇到运算符则压入栈顶
>   2. 若遇到操作数，此时若栈空，则将操作数返回，退出，若栈不空：
>      - 若栈顶是一个运算符，则将操作数压入栈顶。
>      - 若栈顶也是一个操作数，此时若栈中元素少于 2 个则表明出错，退出；其他情况下则取两次栈顶（第二次取得的应为操作符），并按照运算符对两个操作数进行计算（其中取得的栈顶为第一操作数），计算结果暂不压入栈顶，而是当作遇到的一个操作数，转到 2。
>   3. 扫描结束，正确的情况下，输出结果应该在第 2 步返回，并退出；如果执行到此处，表明出错。
>
> (2)
>
> ① 从右向左扫描中缀表达式
>
> 1. 遇到"@"，不做任何处理，转到 ①
> 2. 遇到操作数输出到前缀表达式中，转到 ①
> 3. 遇到")"则压入栈中，转到 ①
> 4. 遇到操作符:
>    - 如果栈顶不为空而且栈顶为操作符而且栈顶操作符的优先级高于该操作符，则将栈顶操作符弹出并输出到前缀表达式中，转到 4
>    - 将该操作符压入栈中
> 5. 遇到"("，将栈中元素依次弹出并输出到前缀表达式中，直至")"出现，并将")"弹出（不输出到前缀表达式中），转到 ①
>
> ② 扫描结束时，若栈中还有元素，则将栈中所有元素依次弹出并输出到前缀表达式中。最后将"@"输出到前缀表达式中

### 2.5.17 用计算机模拟“迷宫问题”，求出其中一条通路。用数组 MAZE(1..m,1..n)表示迷宫，数组元素为 1 意味思路，0 表示通路，MAZE(1,1)为迷宫入口，MAZE(m,n)为迷宫出口，试设计一个算法判别迷宫问题是否有解？有解则输入一条路径

> **解答：**

### 2.5.18 设计 3 个具有三级优先级的队列，并写出插入某个已知优先级的元素的算法

> **解答：** _[code 2-5-18.cpp](./src/2-5-18.cpp)_
>
> 其实还是在一个队列中，逻辑上分为 3 个子队列，具有 3 种优先级。  
> 思路：可以利用二维数组来存放
>
> ```cpp
> #include <cstdlib>
>
> template <typename T>
> class Queue{
>     private:
>         T **Qrank;                      // 二维数组存放各级队列
>         const int rankNum  = 3;         // 当前的最大优先级数
>         int *CurrNum;                   // 一维数组存放各级队列的当前元素个数
>         int maxNum;                     // 记录每一级队列的最大元素个数
>     public:
>         Queue(int maxNumber){
>             for(auto i = 0; i < rankNum; i++){
>                 if((Qrank[i] = new T[maxNumber]) == NULL)
>                     exit(0);
>             }
>             maxNum = maxNumber;
>             CurrNum = new int[rankNum];
>         }
>         ~Queue(){
>             for(int i = 0; i < rankNum; i++)
>                 delete []Qrank[i];
>         }
>         void enQueue(T data, int dataRank){
>             if(dataRank >= rankNum || CurrNum[dataRank] >= maxNum)
>                 return;
>             Qrank[dataRank][CurrNum[dataRank]] = data;
>             CurrNum[dataRank]++;
>         }
> };
> ```

### 2.5.19 现有 4 个元素作为双端队列的输入，可以得到多少种不同的排列

> **解答：**
>
> 双端队列可以两端进行插入删除操作，题目问的是输入排列。第一个元素从左边或右边入队没有区别，以后每种元素有两种入队方式，即有$2^3=8$种。设元素为 a,b,c,d，各排列如下：
>
> &emsp;&emsp;第一次放入 a：  
> &emsp;&emsp;&emsp; a  
> &emsp;&emsp;第二次放入 b：  
> &emsp;&emsp;&emsp; ab ba  
> &emsp;&emsp;第三次放入 c：  
> &emsp;&emsp;&emsp; cab abc cba bac  
> &emsp;&emsp;第四次放入 d：  
> &emsp;&emsp;&emsp; dcab cabd dabc abcd dcba dacd dbac bacd

## 2.6《学习指导》增补习题

### 2.6.1 ~ 2.6.10 [教材习题 2.1.1](#211-设顺序表-a-中的数据元素递增有序设计一个算法将-x-插入到顺序表的适当位置以保持该表的有序性) ~ [教材习题 2.1.10](#2110-设表达式以字符形式已存入数组-en中为表达式的结束符试设计判断表达式中括号和是否匹配的算法)

### 2.6.11 [上机题（栈与队列）2.4.1](#241-利用两个栈-s1-和-s2-来模拟一个队列时如何用栈的运算来实现该队列的运算)

### 2.6.12 试将下列递归过程改成非递归过程

```c
void test(int &sum){
    int x;
    scanf(x);
    if(x == 0)
        sum = 0;
    else{
        test(sum);
        sum += x;
    }
    printf(sum);
}
```

> **解答：** _[code 2-6-12.cpp](./src/2-6-12.cpp)_
>
> ```cpp
> #include <iostream>
> #include <stack>
> using namespace std;
>
> void test2(){
>     int x;
>     stack<int> s1;
>     cin >> x;
>     while(x != 0){
>         s1.push(x);
>         cin >> x;
>     }
>     s1.push(0);
>     int sum = 0;
>     while(!s1.empty()){
>         sum += s1.top();
>         s1.pop();
>         cout << sum << endl;
>     }
>     cout << endl;
> }
> ```

### 2.6.13 [教材习题（栈与队列）2.3.1](#231-如果允许在循环队列的两端都可以进行插入和删除操作要求)

### 2.6.14 [教材习题（栈与队列）2.3.5](#235-假设以带头结点的循环链表表示队列并且只设一个指针指向队尾结点但不设头指针请写出相应的入队列和出队列算法)

### 2.6.15 已知 Q 是一个非空队列，S 是一个空栈。仅用队列和栈的 ADT 函数和少量工作变量，设计一个算法，将队列 Q 的所有元素逆置

> **解答：** _[code 2-6-15.cpp](./src/2-6-15.cpp)_
>
> 将 Q 队列的元素出队并压栈，再出栈入队
>
> ```cpp
> #include <iostream>
> #include <stack>
> #include <queue>
>
> using namespace std;
>
> template <typename T>
> void Revert(queue<T> &Q){
>     stack<T> s;
>     while(!Q.empty()){
>         s.push(Q.front());
>         Q.pop();
>     }
>     while(!s.empty()){
>         Q.push(s.top());
>         s.pop();
>     }
> }
> ```

### 2.6.16 [上机题（栈与队列）2.4.6](#246-已知-ackermann-函数定义如下)

## 2.7《学习指导》增补上机题

### 2.7.1 设计算法求解从集合${1..n}$中选取 $k(k≤n)$个元素的所有组合。例如，从集合${1..4}$中选取 $2$ 个元素的所有组合的输出结果为:$1\ 2，1\ 3，1\ 4，2\ 3，2\ 4，3\ 4$

### 2.7.2 编写算法解决背包问题：设有 $n$ 件物品，重量分别为 $w_1,w_2,...,w_n$ 和一个能装载总重量为 $T$ 的背包。能否从 $n$ 件物品中选择若干恰好使他们的重量之和等于 $T$。若能，则背包问题有解，否则无解。只需要判断是否有解

### 2.7.3 [教材习题（栈与队列）2.3.2](#232-如果用一个循环数组-q0m-1表示队时该队列只有一个队列头指针-front不设队列尾指针-rear而设置计数器-count-用以记录队列中结点的个数试编写算法实现队列的-3-个基本运算判空入队出队)

### 2.7.7 一元稀疏多项式以循环单链表按降幂排列，结点有 3 个域，系数域 coef，指数域 exp 和指针域 next。请编写算法对链表求一阶导数
