# 第二章 -线性表、栈和队列

## 2.2 教材习题解答

### 2.1 设计一个算法，求单链表 X 中，内容为 a 的结点的地址

> **解答：** _[code 2-2-1.cpp](https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2-2-1.cpp)_
>
> 需考虑内容为 a 的地址可能有多个，由于链表中内容为 a 的结点数目不确定，可以选择用一个新链表来存放找到的结点地址。
>
> ```cpp
> // 注：该代码与2-2-1不同，仅表达思路
>
> #include <stdlib.h>
>
> typedef int ELEM;
> typedef struct ListNode* LinkList;
>
> struct ListNode{                    // 单链表节点
>     ELEM data;                      // 数值域
>     LinkList next;                  // 指针域
> };
>
>
> typedef struct AddNode* LinkAddress;
>
> struct AddNode{                     // 存放地址的链表节点
>     LinkList address;               // 指向单链表节点的指针
>     LinkAddress qlink;              // 指向下一个节点指针
> };
>
>
> LinkAddress find(ELEM a, LinkList p){
>     LinkAddress qfirst;
>     qfirst = NULL;                  // 建立一个空链表
>
>     LinkList tmp = p;
>     while(tmp != NULL){
>         if(tmp->data == a){
>             LinkAddress add = (LinkAddress)malloc(sizeof(struct AddNode));
>             add->address = tmp;
>             add->qlink = qfirst;
>             qfirst = add;
>         }
>         tmp = tmp->next;
>     }
>     return qfirst;
> }
> ```

### 2.2 设计一个算法，在单链表 X 中内容为 a 的结点前插入一个内容为 b 的结点

> **解答：** _[code 2-2-2.cpp](https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2-2-2.cpp)_
>
> 需考虑存在多个内容为 a 的结点，遍历链表，在每个这样的节点前插入新结点
>
> ```cpp
> #include <iostream>
> #include "./utils/linear.hpp"
>
>
> template <typename T>
> class NewLink:public LinkList<T>{
>     public:
>         void insert(T value1, T value2){
>             using namespace std;
>             Link<T> *tmp = LinkList<T>::getHead();
>             Link<T> *pre = NULL;                    // 存放当前节点的上一个节点
>             int count;                              // 计数插入元素次数
>             while(tmp != NULL){
>                 if(tmp->data == value1){            // 找到value1
>                     Link<T> *q = new Link<T>(value2, NULL);
>                     if(pre == NULL){                // 第一个节点就是value1时
>                         q->next = tmp;
>                         tmp = q;
>                     }else{
>                         q->next = tmp;
>                         pre->next = q;
>                     }
>                     count ++;
>                 }
>                 pre = tmp;                          // 保存当前节点，作为下次循环的前一个节点
>                 tmp = tmp->next;
>             }
>             if(count == 0)
>                 cout << "No such an element" << endl;
>         }
> };
>
> ```

### 2.3 写出将单链表置逆的算法，即由单链表 A 产生单链表 Z，使得 A 的最后一个元素的是 Z 的第一个元素，依此类推。要求 Z 仍占用 A 所占用的存储单元，并且尽可能地减少使用附加单元

> **解答：** _[code 2-2-3.cpp](https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2-2-3.cpp)_
>
> 用 trail,middle,head 指针指向相邻地 3 个元素，并一次往后挪，每次循环中，把原链表地两个方向改过来，即置逆过来。这样一来，如果把 head 指针看成链表自己地成员变量，只需要两个额外的指针。
>
> ```cpp
> // 注：代码与2-2-3不同，仅表达思路
> #include <stdlib.h>
>
> typedef int ELEM;
> typedef struct ListNode* LinkList;
>
> struct ListNode{
>     ELEM data;
>     LinkList next;
> };
>
> LinkList invert(LinkList Ptr){
>     LinkList newHead, tail;
>     newHead = NULL;
>     while(Ptr){                 // 循环到最后一个节点为止
>         tail = newHead;         // 保存置逆链表的头节点
>         newHead = Ptr;          // 指向原链表的节点
>         Ptr = Ptr->next;
>         newHead->next = tail;   // 原链表的当前节点的下一个节点的指针指向新链表的头节点
>     }
>     return newHead;
> }
> ```

### 2.4 设计一个算法，一个双链表 X，是将指针边里 F 指向的结点插入到指针边里 P 指向的结点之前。请画图表示插入前后双链表的变化情况

> **解答：** _[code 2-2-4.cpp](https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2-2-4.cpp)_
>
> ```cpp
> typedef int Elem;
> typedef struct DbListNode* DbList;
> 
> // 双链表节点
> struct DbListNode{
>  Elem data;              // 数字域
>  DbList rlink;           // 右(后)指针
>  DbList llink;           // 左(前)指针
> };
> 
> // 双链表结构
> struct List{
>  DbList first, last;
> };
> 
> 
> void Insert(DbList F, DbList P, List *X){
>  // 先判断P是否是头节点
>  if(P == X->first){
>      F->rlink = P;
>      P->llink = F;
>      X->first = F;
>  }else{
>      F->rlink = P;
>      F->llink = P->llink;    // F左边的指针指向P左边的指针
>      P->llink->rlink = F;    // P左边节点的右指针指向F
>      P->llink = F;
>  }
> }
> ```
>
> <div align=center><img src="https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/images/2-2-4.jpg" alt="2-2-4" height=75% /></div>

### 2.5 设计一个算法，求循环链表中结点的个数

> **解答：** _[code 2-2-5.cpp](https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2-2-5.cpp)_
>
> 判断已经边里整个链表环的方法：使用一个指针变量 link 从链表首元素向后遍历整个链表，直到 link=first 时，说明该结点即尾结点
>
> ```cpp
> typedef int ELEM;
> typedef struct ListNode* List;
>
> struct ListNode{
>     ELEM data;
>     List next;
> };
>
>
> int Length(List first){         // first为循环链表的头节点
>     List p;
>     p = first;
>     int count = 0;              // 计数
>     while(p->next != first){    // 再次遇见fist代表到达尾节点
>         p = p->next;
>         count ++;
>     }
>     return count;
> }
> ```

### 2.6 设计一个算法，删除循环表中的第一个结点

> **解答：** _[code 2-2-6.cpp](https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2-2-6.cpp)_
>
> _注意：_
>
> - _头结点不是第一个结点，要删除的节点是头节点之后的一个节点（这里我认为是若是用 new 申请的空间，那么头节点的 next 即为第一个节点，若不是，那么 first 指向的就是第一个节点）_
> - _需要考虑特殊情况，如空链表、只有一个节点情况等。_
>
> ```cpp
> #include <iostream>
>
> typedef int ELEM;
> typedef struct Node* ListNode;
>
> struct Node{
>     ELEM data;
>     ListNode next;
>     ListNode pre;
> };
>
> // 循环链表结构，假设用new申请空间
> typedef struct {
>     ListNode first;
>     ListNode last;
> }CLL;
>
>
> // 考虑循环单链表
> void deleteFirstNode1(CLL *pCLL){
>     using namespace std;
>     ListNode tmp;
>     if(pCLL->first == pCLL->last){              // 循环链表为空
>         cout << "The List is NULL, no fist node" << endl;
>         return;
>     }else if(pCLL->first->next == pCLL->last){  // 只有一个节点时
>         tmp = pCLL->first->next;
>         pCLL->first->next = tmp->next;
>         pCLL->last = pCLL->first;
>     }else{                                      // 正常情况
>         tmp = pCLL->first->next;
>         pCLL->first->next = tmp->next;
>     }
>     delete tmp;
> }
>
> // 考虑循环双链表
> void deleteFirstNode2(CLL *pCLL){
>     using namespace std;
>     ListNode tmp;
>     if(pCLL->first == pCLL->last){
>         cout << "The List is NULL, no first node" << endl;
>         return;
>     }else if(pCLL->first->next == pCLL->last){
>         tmp = pCLL->first->next;
>         pCLL->last = pCLL->first;
>         pCLL->first->next = pCLL->first;
>         pCLL->first->pre = pCLL->first;
>     }else{
>         tmp = pCLL->first->next;
>         pCLL->first->next = tmp->next;
>         tmp->next->pre = pCLL->first;
>     }
>     delete tmp;
> }
> ```

### 2.7 设计一个算法，删除向量中第 i 个元素

> **解答：** _[code 2-2-7.cpp](https://github.com/caoshenghui/DataStruct-zhangming/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2-2-7.cpp)_
>
> 向量不是向量表，可以理解为是一维数组（习题教材存在第0个，感觉不合理）
>
> ```cpp
> template <typename T>
> class List{
>     private:
>         int cur_len;            // 数组当前长度
>         T *nodelist;            // 数组
>     public:
>         T remove(int ith){
>             assert((cur_len != 0) && (ith > 0) && (ith <= cur_len));    // 必须存在一个可删除元素
>             T tmp = nodelist[ith-1];
>             for(int i = ith-1; i < cur_len-1; i++){
>                 // 向前移动
>                 nodelist[i] = nodelist[i+1];
>             }
>             cur_len--;
>             return tmp;
>         }
> };
> ```

### 2.8 编号为 1、2、3、4 的 4 辆列车，顺序开进一个栈式结构的站台，请问开出车站的顺序有多少种可能

> **解答：**
>
> 14 种可能
>
> 思路:

### 2.9 两个迎面增长的栈 S1 和 S2 公用 n 个存储单元，写出对栈 S2 进行 push、pop、top 运算的算法，要求整个存储区被占满了才溢出

> **解答：**
>
> 对于双向进行存储的栈，可以让两个栈的底分别位于作为存储的向量的始端和末端，而开始和末尾分别作为栈的初始栈顶，当栈顶相遇时，产生溢出异常。
>
> ```cpp
>
> ```

### 2.10 对于环状的队列，写出计算队列元素个数的程序

> **解答：**
>
> ```cpp
>
> ```

### 2.11 证明：从初始输入序列 1,2,...,n,可以利用一个栈得到输出序列$p_1,p_2,...,p_n,(p_1,p_2,...,p_n是1,2,...,n的一种排列)$的充分必要条件是：不存在下标$i,j,k,$满足$i<j<k$的同时$p_j<p_k<p_i$

> **解答：**
>
> ```cpp
>
> ```

### 2.12 现有中缀表达式$E=((100-4)/3+3*(36-7))*2$，请写出与 E 等价的后缀表达式

> **解答：**
>
> ```cpp
>
> ```

### 2.13 Fibonacci 序列为 0,1,1,2,3,5,8,13,21,34......其中每个元素是前两个元素之和，可递归定义为$fib(n)=fib(n-1)+fib(n-2)$;请设计一个计算$fib(n)$的递归过程，并利用栈来模拟递归调用，将递归过程改成一个非递归过程

> **解答：**
>
> 这里假定$fib(0)=0;fib(1)=1$
>
> ```cpp
>
> ```

### 2.14 用一个栈来模拟表达式的转换过程，画出习题 2.12 的中缀表达式再转成后缀表达式的过程种，栈内容的变化图

> **解答：**
>
> ```cpp
>
> ```

### 2.15 用一个栈来模拟一个较为复杂的后缀表达式的求值过程，画出习题 2.12 所得到的后缀表达式求值过程种栈内容变化图

> **解答：**
>
> 思路：
>
> 1. 遇到一个操作数时，压入栈顶
> 2. 遇到一个运算符时，从栈中两次取出栈顶元素，按照运算符对两个操作数进行计算，然后计算结果压入栈顶

### 2.16 请解决以下问题

- (1) 设计一个计算前缀表达式的算法
- (2) 设计一个将中缀表达式转换成前缀表达式的算法。假设中缀表达式以"@"结束，而前缀表达式以"@"开始

> **解答：**
>
> ```cpp
>
> ```

### 2.17 用计算机模拟“迷宫问题”，求出其中一条通路。用数组 MAZE(1..m,1..n)表示迷宫，数组元素为 1 意味思路，0 表示通路，MAZE(1,1)为迷宫入口，MAZE(m,n)为迷宫出口，试设计一个算法判别迷宫问题是否有解？有解则输入一条路径

> **解答：**
>
> ```cpp
>
> ```

### 2.18 设计 3 个具有三级优先级的队列，并写出插入某个已知优先级的元素的算法

> **解答：**
>
> ```cpp
>
> ```

### 2.19 现有 4 个元素作为双端队列的输入，可以得到多少种不同的排列

> **解答：**
>
> ```cpp
>
> ```

## 2.3 增补习题

### 2.1 设顺序表 va 中的数据元素递增有序，设计一个算法，将 x 插入到顺序表的适当位置，以保持该表的有序性

> **解答：**
>
> ```cpp
>
> ```

### 2.2 设$A=(a_1,...,a_n)$和$B=(b_1,..,b_n)$均为顺序表，A'和 B'分别是 A 和 B 中出去最大共同前缀后的子表。若 A'=B'=空表，则 A=B；若 A'=空表，而 B'≠ 空表，或者两者均不为空表，且 A'的首元小于 B'的首元，则 A<B；否则 A>B。试编写一个比较 A、B 大小的算法

> **解答：**
>
> ```cpp
>
> ```

### 2.3 设线性表中的数据元素依值递增排序，并以单链表作为存储结构。设计一个高效的算法，删除表中所有值大于 mink 且小于 maxk 的元素，同时释放被删除结点的空间，并分析算法的时间复杂度

> **解答：**
>
> ```cpp
>
> ```

### 2.4 假设有两个按元素值递减的有序排序的线性表 A 和 B，均以单链表作为存储结构，设计一个算法将 A 和 B 归并成一个按元素值递减有序排列的线性表 C，并要求利用原表（即表 A 和 B）的结点空间构造表 C

> **解答：**
>
> ```cpp
>
> ```

### 2.5 已知由一个链表表示的线性表中含有 3 类字符的数据元素（字母字符、数字字符和其他字符），设计一个算法将该线性表分割为 3 个循环链表，其中每个循环链表均只含一类字符

> **解答：**
>
> ```cpp
>
> ```

### 2.6 设计一个算法，从一个顺序表中删除第 i 个元素开始的 k 个元素

> **解答：**
>
> ```cpp
>
> ```

### 2.7 已知线性表中元素依值递增有序排列，并以单链表作为存储结构。设计一个算法，删除表中值相同的多余元素，使得操作后表中的所有元素值均不相同，同时释放被删除的结点空间

> **解答：**
>
> ```cpp
>
> ```

### 2.8 已知两个依元素低增的有序排列的顺序表 A 和 B，且同一表中的元素值各不相同，构造一个线性表 C，其元素为 A 和 B 中元素的交集，且表 C 中的元素也依值有序递增排列。设计对 A,B,C 都是顺序表的情况的算法

> **解答：**
>
> ```cpp
>
> ```

### 2.9 要求同增补习题 2.8，设计对 A、B、C 都是单链表的情况的算法。

> **解答：**
>
> ```cpp
>
> ```

### 2.10 设表达式以字符形式已存入数组 E[n]中，"#"为表达式的结束符，试设计判断表达式中括号（"("和")"）是否匹配的算法

> **解答：**
>
> ```cpp
>
> ```

### 2.11 利用两个栈 S1 和 S2 来模拟一个队列。已知栈的 3 个运算定义如下：PUSH(ST, x):元素 x 入 ST 栈；POP(ST, x):ST 栈顶元素出栈，赋给变量 x，Sempty(ST):判 ST 是否为空。如何利用栈的运算来实现改队列的三个运算：enqueue:插入一个元素入队列；dequeue:删除一个元素出队列；queue_empty:判队列为空

> **解答：**
>
> ```cpp
>
> ```

### 2.12 试将下列递归过程改成非递归过程

```c
void test(int &sum){
    int x;
    scanf(x);
    if(x == 0)
        sum = 0;
    else{
        test(sum);
        sum += x;
    }
    printf(sum);
}
```

> **解答：**
>
> ```cpp
>
> ```

### 2.13 如果允许在循环队列的两端都可以进行插入和删除操作。要求

- （1）写出循环队列的类型定义
- （2）写出“从队尾删除”和“从队头插入”的算法

> **解答：**
>
> ```cpp
>
> ```

### 2.14 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针，请写出相应的入队列和出队列算法

> **解答：**
>
> ```cpp
>
> ```

### 2.15 已知 Q 是一个非空队列，S 是一个空栈。仅用队列和栈的 ADT 函数和少量工作变量，设计一个算法，将队列 Q 的所有元素逆置

> **解答：**
>
> ```cpp
>
> ```

### 2.16 已知 Ackermann 函数的定义如下

$$
Ack(m,n) =
\left\{\begin{matrix}
 & n+1 & \text(当m = 0时)\\
 & Ack(m-1,1) & \text(当m \neq 0,n=0时) \\
 & Ack(m-1,Ack(m,n-1)) & \text(当m \neq 0, n \neq 0时)
\end{matrix}\right.
$$

(1) 写出 Ack(2,1 的计算过程)。

(2) 写出计算 Ack(m,n)的非递归算法。

> **解答：**
>
> ```cpp
>
> ```

## 3 教材习题解答

### 3.1 如果允许在循环队列的两端都可以进行插入和删除操作。要求

- 写出循环队列的类型定义
- 写出“从队尾删除”和“从队头插入”的算法

> **解答：**
>
> ```cpp
>
> ```

### 3.2 如果用一个循环菽粟 q[0...m-1]表示队时，该队列只有一个队列头指针 front，不设队列尾指针 rear，而设置计数器 count 用以记录队列中结点的个数。试编写算法实现队列的 3 个基本运算：判空，入队，出队

> **解答：**
>
> ```cpp
>
> ```

### 3.3 试按以下的要求把栈 S 中的元素逆置

- (1)使用额外的两个栈
- (2)使用额外的一个队列
- (3)使用额外的一个栈，外加一些非数组的变量

> **解答：**
>
> ```cpp
>
> ```

### 3.4 试给出用栈所定义的队列

> **解答：**
>
> ```cpp
>
> ```

### 3.5 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），试编写相应的队列初始化，入队和出队算法

> **解答：**
>
> ```cpp
>
> ```

### 3.6 试在一个长度为 n 的数组中实现两个栈，使得二者在元素的总数目为 n 之前都不溢出，并且保证 push 和 pop 的操作时间代价为 O(1)

> **解答：**
>
> ```cpp
>
> ```

### 3.7 编号为 1、2、3、4、5 的 5 辆列车顺序开进栈式结构的站台，试问开出车站的顺序有多少种可能，并予以解释

> **解答：**
>
> ```cpp
>
> ```

### 3.8 证明：从初始输入序列 1,2,...n,可以利用一个栈得到输出序列$p_1,p_2,...,p_n(p_1,p_2,...,p_n是1,2,...,n的一种排列)$的充分必要条件是不存在下表 i、j、k, 满足 i<j<k 同时$p_j<p_k<p_i$

> **解答：**
>
> ```cpp
>
> ```

### 3.9 试利用栈计算后缀表达式 12 8 9 \* + , 并明确写出每个步骤以及每个步骤的状态

> **解答：**
>
> ```cpp
>
> ```

### 3.10 试利用栈计算中缀表达式 a*(b*c-d)+e 转换成后缀表达式。试写出每个步骤以及每个步骤的栈的状态

> **解答：**
>
> ```cpp
>
> ```

### 3.11 试写出一个按照下面定义计算整数 n 和 m 的最大共因此 GCD(n,m)的递归算法

$$
GCD(n,m)
\left\{\begin{matrix}
m & \text(当m\leqslant n且n\quad mod\quad m)\\
GCD(m,n) & 当n<m\\
GCD(m,n\quad mod\quad m) & 否则
\end{matrix}\right.
$$

> **解答：**
>
> ```cpp
>
> ```

### 3.12 试写出计算下面序列的前 n 项和的递归算法，并给出相应的使用栈的非递归算法

$$
1+\frac{1}{2}-\frac{1}{3}+\frac{1}{4}-\frac{1}{5}...
$$

> **解答：**
>
> ```cpp
>
> ```
