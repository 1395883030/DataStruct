# 线性结构

## 线性表

1. 定义

   由同类型数据元素构成有序序列的线性结构，表中元素的个数称为线性表的 _长度_；线性表没有元素时，称为 _空表_；表的起始位置称 _表头_，结束位置称 _表尾_。

2. 抽象数据类型描述

   - 类型名称：线性表
   - 数据对象集是 n(≥0)个元素构成的有序序列$(a_1,a_2,...,a_n)$
   - 操作集：线性表 L∈List,整数 i 表示位置，元素 X∈ElemetType，线性表的基本操作主要有：
     - List MakeEmpty()：初始化一个空线性表 L；
     - ElementType FindKth(int K, List L)：根据位序 K，返回相应元素；
     - int Find(ElementType X, List L)：在线性表 L 中查找 X 第一次出现的位置；
     - void Insert(ElementType X, int i, List L)：在位序 i 前插入一个新元素 X；
     - void Delete(int i, List L)：删除指定位序 i 的元素；
     - int Length(List L)：返回线性表 L 的长度 n。

3. 线性表顺序存储实现

   - 结构

     > ```c
     > typedef struct LNode *List;
     > struct LNode{
     >     ElementType Data[MAXSIZE];
     >     int Last;   // 线性表最后一个元素
     > };
     > struct LNode *L;
     > List Ptrl;
     > ```

   - 初始化（建立空表）

     > ```c
     > List MakeEmpty(){
     >     List Ptrl;
     >     Ptrl = (List)malloc(sizeof(struct LNode));
     >     Ptrl->Last = -1;
     >     return Ptrl;
     > }
     > ```

   - 查找（平均比较次数为(n+1)/2，平均时间性能为 O(n)）

     > ```c
     > int Find(ElementType X, List Ptrl){
     >     int i = 0;
     >     while(i <= Ptrl->Last && Ptrl->Data[i] != X)
     >         i++;
     >     if(i > Ptrl->Last) return -1;    // 没找到返回-1
     >     else return i;                   // 返回的是存储位置
     > }
     > ```

   - 插入（第 i(1≤i≤n+1)个位置上插入一个值为 X 的新元素），平均移动次数为 n/2，平均时间性能 O(n)

     > ```c
     > void Insert(ElementType X, int i, List Prtl){
     >     int j;
     >     if(Ptrl->Last == MAXSIZE-1){
     >         printf("表满");
     >         return;
     >     }
     >     if(i < 1 || i > Ptrl->Last+2){
     >         printf("位置不合法");
     >         return;
     >     }
     >     for(int j = Ptrl->Last; j >= i-1; j--)
     >         Ptrl->Data[j+1] = Ptrl->Data[j];      // i位置后的元素后挪
     >     Ptrl->Data[i-1] = X;
     >     Ptrl->Last++;
     >     return;
     > }
     > ```

   - 删除（删除表的第 i(1≤i≤n)个位置上的元素），平均移动次数(n-1)/2，平均时间性能 O(n)

     > ```c
     > void Delete(int i, List Prtl){
     >     if(i < 1 || i > Ptrl->Last+1){
     >         printf("不存在第%d个元素", i);
     >         return;
     >     }
     >     for(int j = i; j <= Ptrl->Last; j++)
     >         Ptrl->Data[j-1] = Ptrl->Data[j];
     >     Ptrl->Last --;
     >     return;
     > }
     > ```

4. 线性表的链式存储实现

   - 结构

     > ```c
     > typedef struct LNode *List;
     > struct LNode{
     >     ElementType Data;
     >     List Next;
     > };
     > struct LNode L;
     > List Ptrl;
     > ```

   - 表长(O(n))

     > ```c
     > int Length(List Ptrl){
     >     List p = Ptrl;
     >     int count;
     >     while(p){
     >         p = p->Next;
     >         j ++;
     >     }
     >     return j;
     > }
     > ```

   - 查找

     > ```c
     > // 按序号查找
     > List FindKth(int K, List Ptrl){
     >     List p = Ptrl;
     >     int i = 1;
     >     while(p != NULL && i < K){
     >         p = p->Next;
     >         i++;
     >     }
     >     if(i == K) return p;
     >     else return NULL;
     > }
     >
     > // 按值查找
     > List Find(ElementType X, List Ptrl){
     >     List p = Ptrl;
     >     while(p != NULL && p->Data != X)
     >     p = p->Next;
     >     return p;
     > }
     > ```

   - 插入（在第 i-1 个节点后插入一个值为 X 的新节点）
     - 先构造一个新节点，用 s 指向；
     - 再找到链表的第 i-1 个节点，用 p 指向
     - 修改指针，插入节点(p 之后插入新节点是 s)

   > ```c
   > List Insert(ElementType X, int i, List Ptrl){
   >    List p, s;
   >    if(i == 1){                         // 新节点插入表头
   >        s = (List)malloc(sizeof(struct LNode));
   >        s->Data = X;
   >        s->Next = Ptrl;
   >        return s;
   >    }
   >    p = FindKth(i-1, Ptrl);             // 找第i-1个节点
   >    if(p == NULL){
   >        printf("参数i错");
   >        return NULL;
   >    }else{
   >        s = (List)malloc(sizeof(LNode));
   >        s->Data = X;
   >        s->Next = p->Next;
   >        p->Next = s;
   >        return Ptrl;
   >    }
   > }
   > ```

   - 删除（删除链表的第 i 个位置上的节点）
     - 先找到链表的第 i-1 个节点，用 p 指向；
     - 再用指针 s 只想要被删除的节点(p 的下一个节点)；
     - 修改指针，删除 s 所指节点；
     - 释放 s 节点的空间。

   > ```c
   > List Delete(int i, List Ptrl){
   >     List p, s;
   >     if(i == 1){             // 删除的是第一个节点
   >         s = Ptrl;
   >         if(Ptrl != NULL) Ptrl = Ptrl->Next;
   >         else return NULL;
   >         free(s);
   >         return Ptrl;
   >     }
   >     p = FindKth(i-1, Ptrl);
   >     if(p == NULL){
   >         printf("第%d个节点不存在", i-1);
   >         return NULL;
   >     }else if(p->Next == NULL){
   >         printf("第%d个节点不存在", i);
   >         return NULL;
   >     }else{
   >         s = p->Next;
   >         p->Next = s->Next;
   >         free(s);
   >         return Ptrl;
   >     }
   > }
   > ```

## 栈

1. 定义

   具有一定操作约束的线性表，只在一端（栈顶）做插入删除

   - 插入数据：入栈(push)
   - 删除数据：出栈(pop)
   - 后入先出：Last In First Out(LIFO)

2. 抽象数据类型描述

   - 类型名称：堆栈(Stack)
   - 数据对象集：一个有 0 个或多个元素的有穷线性表。
   - 操作集：长度为 MaxSize 的堆栈 S∈Stack，堆栈元素 item∈ElementType
     - Stack CreateStack(int MaxSize)：生成空堆栈，最大长度是 MaxSize；
     - int IsFull(Stack S, int MaxSize)：判断栈是否已满；
     - void Push(Stack S, ElementType item)：元素 item 入栈；
     - int IsEmpty(Stack S)：判断堆栈 S 是否为空；
     - ElementType Pop(Stack S)：删除并返回栈顶元素

3. 栈的顺序存储实现

   - 结构

     > ```c
     > #define MaxSize <元素最大个数>
     > typedef struct SNode *Stack;
     > struct SNode{
     >     ElementType Data[MaxSize];
     >     int Top;
     > };
     > ```

   - 入栈

     > ```c
     > void Push(Stack PtrS, ElementType item){
     >     if(PtrS->Top == MaxSize-1){
     >         printf("栈满");
     >         return;
     >     }else{
     >         PtrS-Data[++(PtrS->Top)] = item;
     >         return;
     >     }
     > }
     > ```

   - 出栈

     > ```c
     > ElementType Pop(Stack PtrS){
     >     if(PtrS->Top == -1){
     >         printf("栈空");
     >         return ERROR;       // ERROR是ElementType特殊值，标志错误
     >     }else{
     >         return (PtrS->Data[(PtrS->Top)--])
     >     }
     > }
     > ```

   - _例题：一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要有空间入栈操作就可以成功。_

     > ```c
     > #define MaxSize <数据元素的个数>
     > struct DStack{
     >     ElementType Data[MaxSize];
     >     int Top1;       // 栈1的栈顶指针
     >     int Top2;       // 栈2的栈顶指针
     > };
     > S.Top1 = -1;
     > S.Top2 = MaxSize;
     >
     > // push
     > void push(Struct DSatck *PtrS, ElementType item, int Tag){
     >     // Tag区分栈1,2
     >     if(PtrS->Top2 - PtrS-Top1 == 1){
     >         printf("栈满");
     >         return;
     >     }
     >     if(Tag == 1)
     >         PtrS->Data[++(PtrS->Top1)] = item;
     >     else
     >         PtrS->Data[--(PtrS->Top2)] = item;
     > }
     >
     > // pop
     > ElementType Pop(struct DStack *PtrS, int Tag){
     >     if(Tag == 1){
     >         if(PtrS->Top1 == -1){
     >             printf("栈1空");
     >             return NULL;
     >         }else
     >             return PtrS->Data[(PtrS->Top1)--];
     >     }else{
     >         if(PtrS->Top2 == MaxSize){
     >             printf("栈2空");
     >             return NULL;
     >         }else
     >             return PtrS->Data[(PtrS->Top2)--];
     >     }
     > }
     > ```

4. 栈的链式存储实现

   栈的链式存储结构实际上就是一个单链表，叫做 _链栈_

   - 结构

     > ```c
     > typedef struct SNode *Stack;
     > struct SNode{
     >     ElementType Data;
     >     struct SNode *Next;
     > };
     > ```

   - 建立空栈

     > ```c
     > Stack CreateStack(){
     >     Stack S;
     >     S = (Stack)malloc(sizeof(struct SNode));
     >     S->Next = NULL;
     >     return S;
     > }
     > ```

   - 判断栈空

     > ```c
     > int IsEmpty(Stack S){
     >     return (S->Next == NULL);
     > }
     > ```

   - 入栈(push)

     > ```c
     > void Push(ElementType item, Stack S){
     >     Stack TmpCell;
     >     TmpCell = (Stack)malloc(sizeof(struct SNode));
     >     TmpCell->Element = item;
     >     TmpCell->Next = S->Next;
     >     S->Next = TmpCell;
     > }
     > ```

   - 出栈(pop)

     > ```c
     > ElementType Pop(Stack S){
     >     Stack FirstCell;
     >     ElementType TopElem;
     >     if(IsEmpty(S)){
     >         printf("栈空");
     >         return NULL;
     >     }else{
     >         FirstCell = S->Next;
     >         S->Next = FirstCell->Next;
     >         TopElem = FirstCell->Element;
     >         free(FirstCell);
     >         return TopElem;
     >     }
     > }
     > ```

## 队列

1. 定义

   具有一定操作约束的线性表，只能在一端插入，另一端删除

   - 插入数据：入队列(AddQ)
   - 删除数据：出队列(DeleteQ)
   - 先进先出：FIFO

2. 抽象数据类型描述

   - 类型名称：队列(Queue)
   - 数据对象集：一个有 0 个或多个元素的有穷线性表
   - 操作集：长度为 MaxSize 的队列 Q∈Queue，队列元素 item∈ElementType
     - Queue CreateQueue(int MaxSize)：生成长度为 MaxSize 的空队列
     - int IsFullQ(Queue Q, int MaxSize)：判断队列 Q 是否已满
     - void AddQ(Queue Q, ElementType item)：将数据元素 item 插入队列
     - int IsEmptyQ(Queue Q)：判断队列是否为空
     - ElementType DeleteQ(Queue Q)：将队首元素队列中删除并返回

3. 队列的顺序存储实现

   通常由一个一维数组和一个记录队列头元素位置的变量 front 以及一个记录队尾元素位置的变量 rear 组成。（通常使用循环队列，空一个位置判定是否队满）

   - 结构

     > ```c
     > #define MaxSize <数据元素的最大个数>
     > struct QNode{
     >     ElementType Data[MaxSize];
     >     int rear;
     >     int front;
     > };
     > typedef struct QNode *Queue;
     > ```

   - 入队

     > ```c
     > void AddQ(Queue PtrQ, ElementType item){
     >     if((PtrQ->rear+1) % MaxSize == PtrQ->front){
     >         printf("队列满");
     >         return;
     >     }
     >     PtrQ->rear = (PtrQ->rear+1) % MaxSize;
     >     PtrQ->Data[PtrQ->rear] = item;
     > }
     > ```

   - 出队

   ```c
   ElementType DeleteQ(Queue PtrQ){
       if(PtrQ->front == PtrQ->rear){
           printf("队列空");
           return ERROR;
       }else{
           PtrQ->front = (PtrQ->front+1) % MaxSize;
           return PtrQ->Data[PtrQ->front];
       }
   }
   ```

4. 队列的链式存储实现

   用单链表实现

   - 结构

     > ```c
     > struct Node{
     >     ElementType Data;
     >     struct Node *Next;
     > };
     > struct QNode{           // 链队列结构
     >     struct Node *rear;  // 指向队尾节点
     >     struct Node *front; // 指向队首节点
     > };
     > typedef struct QNode *Queue;
     > Queue PtrQ;
     > ```

   - 入队

     > ```c
     > void AddQ(Queue PtrQ, ElementType X){
     >     struct Node *TempNode;
     >     if(PtrQ->front == NULL){
     >         // 队列没有元素
     >         TempNode = (struct Node *)malloc(sizeof(struct Node));
     >         TempNode->Data = X;
     >         TempNode->Next = NULL;
     >         PtrQ->front = TempNode;
     >         PtrQ->rear = TempNode;
     >     }else{
     >         // 队列已有元素
     >         TempNode = (struct Node *)malloc(sizeof(struct Node));
     >         TempNode->Data = X;
     >         TempNode->Next = PtrQ->front;
     >         PtrQ->front = TempNode;
     >     }
     > }
     > ```

   - 出队

     > ```c
     > ElementType DeleteQ(Queue PtrQ){
     >     struct Node *FrontCell;
     >     ElementType FrontElem;
     >
     >     if(PtrQ->front == NULL){
     >         printf("队列空");
     >         return ERROR;
     >     }
     >     FrontCell = PtrQ->front;
     >     if(PtrQ->front == PtrQ->rear){
     >         // 只有一个元素
     >         PtrQ->front = PtrQ->rear;
     >     }else{
     >         PtrQ->front = PtrQ->front->Next;
     >     }
     >     FrontElem = FrontCell->Data;
     >     free(FrontCell);
     >     return FrontElem;
     > }
     > ```
