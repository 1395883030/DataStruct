# 第四章 二叉树

## 4.1 教材习题

### 4.1.1 对于 3 个结点 A、B、C，有多少颗不同的二叉树，试画出来

> **解答：** _[code]()_
>
> 解答内容

### 4.1.2 分别按前序、后序、中序列出图 5.21 所示的二叉树结点

<div align="center"><img src="./images/4-1-2.jpg" alt="5.21" height=180 width=40%/></div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.3 以下命题是否为真，若真证明之

&emsp;&emsp;一颗二叉树的所有终端结点(叶结点)，在前序序列、中序序列、后序序列中都按相同的相对位置出现

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.4 找出所有这样的二叉树，其结点在下列两种次序之下都以同样的顺序出现

- （1）前序和后序
- （2）前序和中序
- （3）中序和后序

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.5 写一个递归函数计算二叉树的叶结点个数

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.6 写一个递归函数计算二叉树的高度，只有一个根节点的二叉树高度为 1

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.7 设计一个镜面影射算法，将一颗二叉树的每个结点的左右子结点交换位置。例如将图 5.22(a)所示二叉树转换成 5.22(b)

<div align="center"><img src="./images/4-1-7.jpg" alt="4-1-7" height=200 width=80%/></div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.8 给定结点类型为 BinartTreeNode 的 3 个指针 p、q、rt，设 rt 为根结点，求距离结点 p 和结点 q 最近的这两个结点的共同祖先结点

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.9 画出图 5.22(a)所示二叉树的二叉链表存储表示图，5.22 图见 4.1.7

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.10 对于 3 个关键码值 A、B、C 有多少个不同的二叉搜索树？试将其画出来

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.11 试证明：二叉搜索树结点的中序序列就是二叉搜索树结点按关键码值排序的序列

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.12 写出从二叉搜索树中删除一个关键码的的递归算法

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.13 给出关键码序列{wxw, wxz, wzw, wzy, wzz, yyw, yyx, zww, zwx, zwy, zyw, zyx, zyy, zyz}。从空二叉搜索树（BST）开始，按照上诉关键码出现的顺序依次插入，画出插入所有结点后的 BST

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.14 编写以恶递归函数 search()，传入参数为一棵二叉树（不是二叉搜索树 BST）和一个值 K，如果值 K 出现在数中则返回 true，否则返回 false。相应的，写出一个等价的非递归函数

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.15 编写一个递归函数 smallcount()，传入一颗二叉搜索树的根和值 K，返回小于或等于 K 结点的数目，函数 smallcount()应尽可能少地访问 BST 的结点。相应的，写出一个等价的非递归函数 samllcount()

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.16 编写一个递归函数 printRange()，传入一个 BST、一个较小的值和一个较大的值，按照顺序打印出介于两个值之间的所有结点。函数 printRange()应尽可能少地访问 BST 结点

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.17 编写一个 IsBST，传入参数为一颗二叉树，如果该二叉树是 BST 则返回 true，否则返回 false

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.18 编写一个函数 IsMinHeap()，传入参数为一个数组，如果该数组中地值满足最小堆的定义则返回 true，否则返回 false

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.19 初始关键码序列为{E, D, X, K, H, L, M, C, P}，试给出用筛选法所建的最小堆，并写出其相应的序列，在建堆过程中，移位次数是多少

&emsp;&emsp;提示：一次移位就是对关键码的一次赋值操作。例如，交换 Arr[i]与 Arr[j]的操作是 3 次移位：tmp = A[i], A[i] = A[j], A[j] = tmp。不考虑下标变量的赋值(例如 i = 100 不算一次赋值)

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.20 对于给出的一组权 W={1,4,9,16,25,36,49,64,81,100}，构造具有最小带权外部路径长度的扩充二叉树，并求出它的带权外部路径长度

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.21 给定一组权$W_0,W_1,...,W_{n-1}$，说明怎样构造一个具有最小带权外部路径长度的扩充 k 叉树。试对权集 1,4,9,16,25,36,49,64,81,100 来具体构造一个这样的扩充三叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.1.22 任何包括 n 个结点的二叉树的二叉链表表示中，2n 个指针中都只有 n-1 个用来指示结点的左右子节点，二另外 n+1 个为空。可以用指向结点按某种次序周游的前驱和后继的指针来替代这些空的指针。这种附加的指针称作“线索”，加进了线索的二叉链表称作穿线二叉树。由于有了线索的存在而使得周游二叉树和找结点在指定次序下的前驱、后继的算法变得很简单。例如图 5.23 就是一个中序穿线树。在穿线树中如果结点有左子树，那么它的左指针 left 就指向其左孩子，否则 left 指向其前驱结点；如果有右子树，那么它的右指针 right 就指向右孩子，否则 right 就指向其后继结点。为区分指针和线索，需要在每个结点中增加两个标志位，分别指示左右指针位置中存的是指针还是线索。试给出将二叉树以中序遍历使其变成穿线树的线索化算法。以下给出了穿线二叉树的结构

| left | ltag | info | rtag | right |
| :--: | :--: | :--: | :--: | :---: |


<div align=center>
<img src="./images/4-1-22.jpg" alt="4-1-22" height=250 width=50% />

</div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

## 4.2 上机题

### 4.2.1 二叉树两个结点间的最小距离

&emsp;&emsp;定义二叉树两个结点间的最小距离为：这两个结点的最近公共祖先结点分别到这两个结点的路径长度之和。试设计一种方法，找出给定二叉树中任意两个结点之间的最小距离，可以考虑以图形显示

### 4.2.2 表达式二叉树

&emsp;&emsp;表达式可以用表达式二叉树表示，对于简单的四则运算表达式，请实现以下功能

- （1）对于任意给出的前缀表达式（不带括号）、中缀表达式（可以带括号）或后缀表达式（不带括号），能够在计算机内部构造出一颗表达式二叉树，并且以图示显示出来（字符图或图形的形式）
- （2）按照用户的要求，输出相应的前缀表达式（不带括号）、中缀表达式（可以带括号，但不允许冗余括号）或后缀表达式（不带括号）

&emsp;&emsp;提示：所谓中缀表达式中的冗余括号，就是去掉该括号不影响表达式的计算。例如“(a+b)+a”中的括号是冗余的，可以表示成不冗余的“a+b+a”。

### 4.2.3 逻辑表达式推演

&emsp;&emsp;一个逻辑表达式如果对于其变元的任意一种取值都为真， 则称为重言式；反之，如果对于其变元的任一一种取值都为假，则称矛盾式；否则，既非重言式也非矛盾式。编写程序通过真值判断一个逻辑表达式属于哪一类。

&emsp;&emsp;（1）逻辑运算符包括“|”、“ ”、“~”，分别标识逻辑或、与、非，表达式包含括号

&emsp;&emsp;（2）如果是既非重言式，也非矛盾式，试按照用户给定变元的取值（可选）显示逻辑表达式的值

&emsp;&emsp;（3）按照用户的要求可以打印真值表

### 4.2.4 Huffman 编码

&emsp;&emsp;完成根据代码 5.12 建立 Huffman 编码树的源代码，包括计算各个字母对应代码的函数以及对信息进行编码于解码的函数。这个对象可以进一步扩展以支持对文件的压缩，为此必须增加两个步骤：

&emsp;&emsp;（1）扫描整个文件以生成文件各个字母的实际使用频率

&emsp;&emsp;（2）在编码文件的开头存储 Huffman 树，以便解码函数使用

### 4.2.5 优先队列

&emsp;&emsp;利用最大堆实现一个优先队列，对于队列的操作应该至少支持以下几种指令

&emsp;&emsp;&emsp;&emsp; void enqueue(int ObjectID, int Priority);

&emsp;&emsp;&emsp;&emsp; int dequeue();

&emsp;&emsp;&emsp;&emsp; void changeweight(int ObjectID, int newPriority)

&emsp;&emsp;函数 enqueue()向优先队列中插入一个 ID 号为 ObjcetID、优先级为 priority 的新对象。函数 deququq()从优先队列中删除优先级最高的对象，并返回该对象的 ID 号。函数 changeweight 将 ID 号为 ObjectID 的对象的优先级改为 newPriority。需要建立一种机制来获取所需对象在堆的位置，还需要对堆实现进行修改，以存储对象在数组中的位置，以便在辅助数据结构中记录针对堆中对象的修改

## 4.3 《学习指导》教材习题解答

### 4.3.1 ~ 4.3.9 [教材习题 4.1.1](#411-对于3个结点abc有多少颗不同的二叉树试画出来) ~ [教材习题 4.1.9](#419-画出图522a所示二叉树的二叉链表存储表示图522图见417)

### 4.3.10 画出图 5.2.1 所示二叉树的中序穿线二叉树存储表示

<div align="center"><img src="./images/4-1-2.jpg" alt="5.21" height=180 width=40%/></div>

### 4.3.11 编写算法在中序穿线二叉树里找指定结点在后续周游中的前驱

### 4.3.12 编写算法按后续周游中序穿线树

### 4.3.13 设计一个算法，往中序穿线二叉树指定结点的左边插入一个新结点。规定插入这样进行：r 指向要插入的新节点，p 指向穿线二叉树里的一个结点，将新结点插进来作为 p 指向结点的左子树的根。p 指向结点原来的左子树现在作为新结点的左子树（新结点的右子树为空）。即在中序序列里，新结点刚好插到 p 所指向的结点之前

### 4.3.14 ~ 4.3.25 [教材习题 4.1.10](#4110-对于3个关键码值abc有多少个不同的二叉搜索树试将其画出来) ~ [教材习题 4.1.21](#4121-给定一组权w_0w_1w_n-1说明怎样构造一个具有最小带权外部路径长度的扩充k叉树试对权集149162536496481100来具体构造一个这样的扩充三叉树)

### 4.3.26 一组包含不同权的字母已经对应好 Huffman 编码，如果某一字母对应编码 001，则

- （1）什么编码不可能对应其他字母
- （2）扫描编码肯定对应其他字母

## 4.4 《学习指导》教材上机题解答

### 4.4.1 ~ 4.4.5 [上机题 4.2.1](#421-二叉树两个结点间的最小距离) ~ [上机题 4.2.5](#425-优先队列)

## 4.5 《学习指导》增补习题

### 4.5.1 已知二叉树各节点的前序、中序周游分别为 ABCDEF 和 CBAEDF，试画出二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.2 将图 4.16 中的二叉树按中序线索化，结点 X 的右指针和 Y 的左指针分别指向\_\_

<div align="center"><img src="./images/4.5-2.jpg" alt="4.5-2" height=250 width=60% /></div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.3 已知一个二叉树的前序及中序遍历结果，设计一个算法恢复该二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.4 设计一个算法，在二叉树中查找值为 x 的结点，并打印出所有的祖先

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.5 设计一个算法，求任意二叉树中第一条最长的路径长度，并输出次路径上各结点的值

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.6 试编写一个算法，判定给定二叉树是否为满二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.7 试编写一个算法，判定给定二叉树是否为完全二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.8 假设二叉树采用链表结构进行存储，编写一个函数，求根结点到任意一个结点 p 之间的路径

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.9 设计一个算法，判断两棵二叉树是否相似。所谓二叉树 T1 和 T2 相似，指的是 T1 和 T2 都是空的二叉树，或者 T1 和 T2 的根结点是相似的，T1 的左子树和 T2 的左子树是相似的且 T1 的右子树和 T2 的右子树是相似的

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.10 有 n 个结点的二叉树，已知叶节点个数为$n_0$，写出求度为 1 的结点的个数$n_1$的计算公式；若此树是深度为 k 的完全二叉树，写出 n 为最小的公式；若二叉树中仅有度为 0 和度为 2 的结点，写出求改二叉树结点个数 n 的公式

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.11 有一颗完全二叉树，其结点按层次顺序存于一维数组 A(1:n)中，试编写一个算法，建立该二叉树的二叉链表存储结构

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.12 试讨论，能否在一颗中序全线索二叉树上查找给定结点 x 在前序序列中的后继，在后序序列中的后继

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.13 已知某电文中共出现了 10 种不同的字母，每个字母出现的频率分别为 A:8,B:5,C:3,D:2,E:7,F:23,G:9,H:11,I:2,J:35，现对这段电文用 3 进制进行编码（即码字由 0,1,2 组成），问电文编码总长度至少多少位？请画出相应的图

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

### 4.5.14 已知某字符串 S 总共有 8 种字符，各种字符分别出现 2 次，1 次，4 次，5 次，7 次，3 次，4 次和 9 次，对该字符串用{0,1}进行前缀编码，问该字符串的编码至少有多少位

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
>
> ```

## 4.6 《学习指导》增补上机题

### 4.6.1 利用 BST 存储数据库记录实现一个城市数据库。每个数据库结点包含城市名称（一个长度任意的字符串）和以整数 x 与 y 表示的城市坐标。根据城市的名称组织该 BST。这个数据库应该能够记录允许的插入，根据名称或坐标删除，以及根据名称或坐标进行检查，并且能够打印出与指定点的距离在给定值内的所有城市的记录。它应该能够使用某种顺序将 BST 写入磁盘，并且能够读出使用相同顺序存储的 BST 存储文件

### 4.6.2 已知一颗二叉树的前序遍历和中序遍历结果（例如 4.17 中的二叉树，其前序遍历为 ABCDEF，中序遍历为 DBEAFC），请编写一个算法还原这颗二叉树

<div align="center"><img src="./src/../images/4-6-2.jpg" alt="4-6-2" height=180, width=45% /></div>

### 4.6.3 已知一颗中序全线索二叉树（如图 4.18 所示），请编写一个算法后序遍历这颗中序全线索二叉树，算法中不允许使用栈和递归

<div align="center"><img src="./src/../images/4-6-3.jpg" alt="4-6-3" height=200, width=70% /></div>
