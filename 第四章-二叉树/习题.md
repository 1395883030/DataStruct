# 第四章 二叉树

## 4.1 教材习题

### 4.1.1 对于3个结点A、B、C，有多少颗不同的二叉树，试画出来

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.2 分别按前序、后序、中序列出图5.21所示的二叉树结点

<div align="center"><img src="./images/4-1-2.jpg" alt="5.21" height=250 width=40%/></div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.3 以下命题是否为真，若真证明之

&emsp;&emsp;一颗二叉树的所有终端结点(叶结点)，在前序序列、中序序列、后序序列中都按相同的相对位置出现

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.4 找出所有这样的二叉树，其结点在下列两种次序之下都以同样的顺序出现

- (1) 前序和后序
- (2) 前序和中序
- (3) 中序和后序

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.5 写一个递归函数计算二叉树的叶结点个数

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.6 写一个递归函数计算二叉树的高度，只有一个根节点的二叉树高度为1


> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.7 设计一个镜面影射算法，将一颗二叉树的每个结点的左右子结点交换位置。例如将图5.22(a)所示二叉树转换成5.22(b)

<div align="center"><img src="./images/4-1-7.jpg" alt="4-1-7" height=250 width=80%/></div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.8 给定结点类型为BinartTreeNode的3个指针p、q、rt，设rt为根结点，求距离结点p和结点q最近的这两个结点的共同祖先结点

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.9 画出图5.22(a)所示二叉树的二叉链表存储表示图，5.22图见4.1.7

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.10 对于3个关键码值A、B、C有多少个不同的二叉搜索树？试将其画出来

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.11 试证明：二叉搜索树结点的中序序列就是二叉搜索树结点按关键码值排序的序列

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.12 写出从二叉搜索树中删除一个关键码的的递归算法

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.13 给出关键码序列{wxw, wxz, wzw, wzy, wzz, yyw, yyx, zww, zwx, zwy, zyw, zyx, zyy, zyz}。从空二叉搜索树（BST）开始，按照上诉关键码出现的顺序依次插入，画出插入所有结点后的BST

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

#### 4.1.14 编写以恶递归函数search()，传入参数为一棵二叉树（不是二叉搜索树BST）和一个值K，如果值K出现在数中则返回true，否则返回false。相应的，写出一个等价的非递归函数

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.15 编写一个递归函数smallcount()，传入一颗二叉搜索树的根和值K，返回小于或等于K结点的数目，函数smallcount()应尽可能少地访问BST的结点。相应的，写出一个等价的非递归函数samllcount()

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.16 编写一个递归函数printRange()，传入一个BST、一个较小的值和一个较大的值，按照顺序打印出介于两个值之间的所有结点。函数printRange()应尽可能少地访问BST结点

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.17 编写一个IsBST，传入参数为一颗二叉树，如果该二叉树是BST则返回true，否则返回false

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.18 编写一个函数IsMinHeap()，传入参数为一个数组，如果该数组中地值满足最小堆的定义则返回true，否则返回false

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.19 初始关键码序列为{E, D, X, K, H, L, M, C, P}，试给出用筛选法所建的最小堆，并写出其相应的序列，在建堆过程中，移位次数是多少

提示：一次移位就是对关键码的一次赋值操作。例如，交换Arr[i]与Arr[j]的操作是3次移位：tmp = A[i], A[i] = A[j], A[j] = tmp。不考虑下标变量的赋值(例如i = 100不算一次赋值)

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.20 对于给出的一组权W={1,4,9,16,25,36,49,64,81,100}，构造具有最小带权外部路径长度的扩充二叉树，并求出它的带权外部路径长度

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.21 给定一组权$W_0,W_1,...,W_{n-1}$，说明怎样构造一个具有最小带权外部路径长度的扩充k叉树。试对权集1,4,9,16,25,36,49,64,81,100来具体构造一个这样的扩充三叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.1.22 任何包括n个结点的二叉树的二叉链表表示中，2n个指针中都只有n-1个用来指示结点的左右子节点，二另外n+1个为空。可以用指向结点按某种次序周游的前驱和后继的指针来替代这些空的指针。这种附加的指针称作“线索”，加进了线索的二叉链表称作穿线二叉树。由于有了线索的存在而使得周游二叉树和找结点在指定次序下的前驱、后继的算法变得很简单。例如图5.23就是一个中序穿线树。在穿线树中如果结点有左子树，那么它的左指针left就指向其左孩子，否则left指向其前驱结点；如果有右子树，那么它的右指针right就指向右孩子，否则right就指向其后继结点。为区分指针和线索，需要在每个结点中增加两个标志位，分别指示左右指针位置中存的是指针还是线索。试给出将二叉树以中序遍历使其变成穿线树的线索化算法。以下给出了穿线二叉树的结构

|left|ltag|info|rtag|right|
|:-:|:-:|:-:|:-:|:-:|:-:|

<div align=center>
<img src="./images/4-1-22.jpg" alt="4-1-22" height=400 width=80% />

</div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

## 4.2 增补习题

### 4.2.1 已知二叉树各节点的前序、中序周游分别为ABCDEF和CBAEDF，试画出二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.2 将图4.16中的二叉树按中序线索化，结点X的右指针和Y的左指针分别指向__

<div align="center"><img src="./images/4-2-2.jpg" alt="4-2-2" height=250 width=60% /></div>

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.3 已知一个二叉树的前序及中序遍历结果，设计一个算法恢复该二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.4 设计一个算法，在二叉树中查找值为x的结点，并打印出所有的祖先

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.5 设计一个算法，求任意二叉树中第一条最长的路径长度，并输出次路径上各结点的值

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.6 试编写一个算法，判定给定二叉树是否为满二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.7 试编写一个算法，判定给定二叉树是否为完全二叉树

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.8 假设二叉树采用链表结构进行存储，编写一个函数，求根结点到任意一个结点p之间的路径

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.9 设计一个算法，判断两棵二叉树是否相似。所谓二叉树T1和T2相似，指的是T1和T2都是空的二叉树，或者T1和T2的根结点是相似的，T1的左子树和T2的左子树是相似的且T1的右子树和T2的右子树是相似的

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.10  有n个结点的二叉树，已知叶节点个数为$n_0$，写出求度为1的结点的个数$n_1$的计算公式；若此树是深度为k的完全二叉树，写出n为最小的公式；若二叉树中仅有度为0和度为2的结点，写出求改二叉树结点个数n的公式

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.11 有一颗完全二叉树，其结点按层次顺序存于一维数组A(1:n)中，试编写一个算法，建立该二叉树的二叉链表存储结构

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.12 试讨论，能否在一颗中序全线索二叉树上查找给定结点x在前序序列中的后继，在后序序列中的后继

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.13 已知某电文中共出现了10种不同的字母，每个字母出现的频率分别为A:8,B:5,C:3,D:2,E:7,F:23,G:9,H:11,I:2,J:35，现对这段电文用3进制进行编码（即码字由0,1,2组成），问电文编码总长度至少多少位？请画出相应的图

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

### 4.2.14 已知某字符串S总共有8种字符，各种字符分别出现2次，1次，4次，5次，7次，3次，4次和9次，对该字符串用{0,1}进行前缀编码，问该字符串的编码至少有多少位

> **解答：** _[code]()_
>
> 解答内容
>
> ```cpp
> 
> ```

