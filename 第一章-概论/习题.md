# 第一章 概论

## 1.2 教材习题解答

### 1.1 设字符集为字母和数字的集合，字符的顺序为 A,B,C,...,Z,0,1,2,..9,请将下列字符串按字典顺序排列、存储：PAB,5C,PABC,CXY,CRSI,7,B899,B9,并分析可以采取的存储方案

> **解答:**
>
> 可以采用的存储结构有顺序数组和链表以及索引等方式
>
> 1. 采用二维数组，需要 array[8][5]
>    - 优点：结构紧凑，直观简单，代码十分容易
>    - 缺点：为每个单词都开辟了同样长度的空间，造成空间浪费
> 2. 用链表, 结构可定义为：
>
>    ```cpp
>    struct strings{
>     char string[MAX_LENGTH];
>     string *pNext;
>    }
>    ```
>
>    - 优点：若有后序操作，如增删，则效率高，并且可以使用不连续节点
>    - 缺点：操作过程相对复杂，容易出错，而且排序过程需要从表头开始沿链索一个节点、一个节点地比较搜索，相当费时。
>
> 3. 索引存储
>    索引存储是顺序存储的一种推广。使用一个字符串 char data[500]，将大小长度不等的数据节点（单词）顺序存储其中。并使用一个字符指针数组 char \*index[n]存储一系列的指针，每个指针指向存储区域的一个数据节点。排序时，直接对 index 中的地址值进行调换修改即可，而不用修改 data 中的任何内容。
>
>    - 优点：由于单词长度不同，在存储时充分考虑了这个因素，可以节省空间。此外由于交换的不是单词本身二是单词的地址，可以节省时间，从空间和时间两方面得到优化。

### 1.2 有一个包括 100 个元素的数组，每个元素的值都是实数，请写出求最大元素的值及其位置的算法，讨论它所可能采取的存储结构

> **解答：** _[code 1-2-2.cpp](./src/1-2-2.cpp)_
>
> _注意：要求实数，且需要考虑多个最大值情况_
> 可采用顺序数组，链表和索引。顺序数组最优。
>
> ```cpp
> #include <iostream>
>
> using namespace std;
>
>
> int main(){
>     // Num存放100个实数
>     double Num[100] = {4542.9, 8, 3333, 4542.9, 8, 33, 22, 123, 3412, 4542.9, 56, 77, 45};
>     int pos[100];                   //记录最大值所在位置的数组
>     int position = 0;               //初始化设定数组的第一个元素为最大值
>     int j;                          //指示位置数组pos的下标
>     for(int i = 1; i < 100; i++){
>         if(Num[i] > Num[position]){
>             position = i;           //更新最大元素的位置
>             j = 1;                  //位置数组pos的下标恢复为1，下标为0的位置为position预留
>         }else if(Num[i] == Num[position])
>             pos[j++] = i;           //记下重复最大值的位置
>     }
>     pos[0] = position;
>     if(j < 100)
>         pos[j] = -1;                //-1是标识值，前j个元素均为最大值位置，相当于哨兵
>
>     cout << "最大值为:" << Num[position] << endl;
>     cout << "最大值所在的位置为:";
>     for(int i = 0; i < 100; i++){
>         if(pos[i] == -1)
>             break;
>         cout << pos[i]+1 <<" ";
>     }
>     cout << endl;
> }
> ```

### 1.3 以学生课程表为例，讨论它的数据结构，叙述其逻辑结构、存储结构和相关运算等三个方面

## 1.3 增补习题

### 1.1 设计一个算法，自大到小依次输出顺序读入的三个整数 x,y,z 的值

> **解答：** _[code 1-3-1.cpp](./src/1-3-1.cpp)_
>
> 若整数过多可考虑使用排序算法
>
> ```cpp
> #include <iostream>
>
> using namespace std;
>
> int main(){
>     int x, y, z;
>     cin >> x >> y >> z;
>     int t;          // 临时变量，用来交换值
>     if(x < y){
>         t = x;
>         x = y;
>         y = t;
>     }
>     if(x < z){
>         t = z;
>         z = x;
>         x = z;
>     }
>     if(y < z){
>         t = y;
>         y = z;
>         z = t;
>     }
>     cout << x << " " << y << " " << z << endl;
>     return 0;
> }
>
> // 扩展，排序算法
> ```

### 1.2 已知斐波那契序列的定义如下，试编写求 k 阶斐波那契序列第 m 项值的函数算法，k 和 m 均作为该函数的参数

$$
\begin{aligned}
&f_0 = 0, f_1 = 0,...,f_{n-2}=0, f{n-1} = 0;  \\
&f_n = f_{n-1} + f_{n-2}+...+f_{n-k}, n = k,k+1,...
\end{aligned}
$$

> **解答：** _[code 1-3-2.cpp](./src/1-3-2.cpp)_
>
> 观察可知，第 k 项即$f_{k-1}$项为 1，前 k-1 项均为 0。第 k 项之后每一项均为前 k 项之和。如：
>
> $$
> 当k为2时：0,1,1,2,3,5,8\\
> 当k为3时: 0,0,1,1,2,4,7
> $$
>
> 所以当$m<=k-1$时，第 m 项为 0。
> _数组方法：_
>
> ```cpp
> #include <iostream>
>
> #define MAX 1000
>
> using namespace std;
>
> // 数组法
> void Fibonacci_arr(int k, int m, int &f){
>     int arr[MAX];
>     if(m <= k-1)
>         f = 0;
>     else{
>         for(int i = 0; i < k-1; i++)
>             arr[i] = 0;                 // 前K-1项均为零
>         arr[k-1] = 1;
>         for(int i = k; i < m; i++){
>             int sum = 0;
>             for(int j = i-k; j < i; j++)  // 前k项相加
>                 sum += arr[j];
>             arr[i] = sum;
>         }
>         f = arr[m-1];
>     }
> }
> ```
>
> 递归法：
>
> $$
> \begin{aligned}
> f_n &= f_{n-1} + f_{n-2} + ... + f_{n-k} \\
> f_{n-1} &= f_{n-2} + f_{n-3} + ... + f_{n-k-1}\\
> \end{aligned}
> $$
>
> 两式相减得:
> $f_n = 2f_{n-1} - f_{n-k-1}$
>
> ```cpp
> int Fibonacci_rec(int k, int m){
>     if(m <= k-1)
>         return 0;
>     else if((m == k) || (m == k+1))     // 第k项和k+1均为1
>         return 1;
>     else
>         return 2*Fibonacci_rec(k, m-1) - Fibonacci_rec(k, m-k-1);
> }
> ```

### 1.3 设计一个算法，计算$i!*2^i$的值并存入数组 a[0..arrsize-1]的第$i-1$个分量中$(i=1,2,...,n)$。假设计算机允许的整数最大值为 maxint，则当$n>arrsize$或对某个$k(1\leq k\leq n)$，当$k!*2^i>maxint$时，按出错处理

> **解答：** _[code 1-3-3.cpp](./src/1-3-3.cpp)_
>
> ```cpp
> #include <iostream>
> #include <climits>
>
> using namespace std;
>
> #define arrsize 300
> #define maxint INT_MAX
>
>
> // 非递归
> bool Algo(int i, int a[]){
>     if(i < 1 || (i > arrsize))
>         return false;
>     for(int j = 1; j <= i; j++){
>         if(j == 1)
>             a[j-1] = 2;
>         else{
>             if(a[j-2]*2*j > maxint)
>                 return false;
>             a[j-1] = a[j-2] * 2 * j;
>         }
>     }
>     return true;
> }
> ```

### 1.4 设计一个算法，计算多项式$p_n(x) = \sum_{i=0}^{n}a_ix^i$的值

> **解答：** _[code 1-3-4.cpp](./src/1-3-4.cpp)_
>
> ```cpp
> #include <cmath>
>
> using namespace std;
>
> int Algo(int a[], int x, int n){
>     int tmp;
>     int i;
>     for(i = 1, tmp = 0; i <= n; i++)
>         tmp += a[i-1] * pow(x,i-1);
>     return tmp;
> }
> ```

### 1.5 假设有 A、B 两个高校进行田径对抗赛，各高校的单项成绩均存入计算机中，构成一张表，表中的每一行形式如下，设计算法处理下述表格，统计各高校的男女总分和团体总分并输出

| 项目名称 | 性别 | 校名 | 成绩 | 得分 |
| -------- | ---- | ---- | ---- | ---- |


> **解答：** _[code 1-3-5.cpp](./src/1-3-5.cpp)_
>
> _部分代码如下：_
>
> ```cpp
> typedef enum {a, b} schoolname;
> typedef enum {female, male} sex;
> typedef enum {x, y, z} event;
>
>
> class grade{
>     public:
>         schoolname school;          // 学校
>         sex sex;                    // 性别
>         event e;                    // 项目名称
>         int score;                  // 得分(成绩)
>         grade(){};
>         grade(schoolname sn, sex s, event e, int sc);
> };
>
>
> class sum{
>     private:
>         schoolname school;          // 校名
>         int malesum;                // 男总分
>         int femalesum;              // 女总分
>         int totalsum;               // 团体总分
>     public:
>         sum();
>         sum(schoolname sn);
>         void getscore(grade gra[], int n);   // 获取分数
>         void showscore();           // 输出总分
> };
> ```

### 1.6 分析下列程序段中循环语句的执行次数

```c
i = 0; s = 0; n = 100;
do{
    i = i + 1;
    s = s + 10*i;
}while(!((i < n) && (s < n)))
```

> **解答：**
>
> 执行了一次，执行一次后 while 中的条件已不满足

### 1.7 下列算法对一个 n 位二进制数加 1，假如无溢出，该算法的最坏时间复杂度是什么？请分析它的平均时间复杂度

```c
void Inc(A[n]){
    int i;
    i = n - 1;
    while(A[i] == 1){
        A[i] = 0;
        i = i - 1;
    }
    A[i] = 1;
}
```

> **解答：**
>
> 最好时间复杂度是$O(1)$，最坏时间复杂度是$O(n)$。
>
> 假如无溢出，那么最坏情况是除了最高位为 0 其他位均为 1，即循环执行 n-1 次，每次循环两次赋值，循环中一共 2(n-1)次赋值操作，循环外两次赋值，一共是 2n 次。最好情况则是最低位为 0，不进入循坏，仅两次赋值操作。
>
> 所以平均时间复杂度是 2n，即$O(n)$

### 1.8 阅读下列算法，指出算法 A 的功能和时间复杂度，其中 h,g 分别是单循环链表中的两个节点指针

```c
void B(int *s, int *q){
    int *p;
    p = s;
    while(p->next != q)
        p = p->next;
    p->next = s;
}

void A(int *h, int *g){
    B(h, g);
    B(g, h);
}
```

### 1.9 调用 C 语言函数$f(n)$，回答下列问题

- 试指出$f(n)$值的大小，并写出$f(n)$值的推导过程。
- 假定 n=5，试指出$f(5)$值得大小和执行$f(5)$时输出结果。

```c
int f(int n){
    int i, j, k, sum = 0;
    for(i = 1; i < n; i++){
        for(j = n; j > i-1; j--)
            for(k = 1; k < j; k++)
                sum++;
        printf("sum = %d\n", sum);
    }
    return sum;
}
```

> **解答：**
>
> - 当 i=1 时，第二重循环执行 n 次，第三重循环执行(n-1)+(n-2)+...+1+0 次  
>   当 i=2 时，第二重循环执行 n-1 次，第三重循环执行(n-1)+(n-2)+...+1 次  
>   当 i=n-1 时，第二重循环执行 2 次，第三重循环执行(n-1)+(n-2)次  
>   所以有：
>   $$
>   \begin{aligned}
>   f(n)&=(0+1+...+(n-1))+(1+...+(n-1))+...+((n-2)+(n-1))  \\
>   &=1×0+2×1+3×2+...+(n-1)(n-2)+(n-1)(n-1)+(n-1)-(n-1)  \\
>   &=1×0+2×1+3×2+...+(n-1)(n-2)+n(n-1)-(n-1)  \\
>   \end{aligned}
>   $$
>   用裂项法求解，同乘 3 得：
>   $$
>   \begin{aligned}
>   3f(n)&=1×2×3+2×3×3+...+(n-1)×n×3-3×(n-1)  \\
>   &=1×2×3+2×3×(4-1)+3×4×(5-2)...+(n-1)×n×[(n+1)-(n-2)]-3(n-1)  \\
>   &=1×2×3+2×3×4-1×2×3+3×4×5-2×3×4+...+(n-1)×n×(n+1)-(n-2)(n-1)n-3(n-1)  \\
>   &=(n-1)n(n+1)-3(n-1)  \\
>   \Rightarrow f(n)&=(n-1)n(n+1)/3-(n-1)
>   \end{aligned}
>   $$
> - 当 $n=5$ 时，$f(n)=4×5×6/3-4=36$与程序运行结果一致

### 1.10 设 n 是偶数，计算运行下列程序段后 m 的值并给出该程序段的时间复杂度

```c
m = 0;
for(i = 1; i <= n; i++)
    for(j = 2*i; j <= n; j++)
        m = m + 1
```

> **解答：**
> 外层循环执行 n 次，有效次数是 n/2，1 次赋值操作
>
> 当 i=1 时，j 循环 n/2；当 i=2 时，j 循环 n/4，所以可得 m 执行次数为：
> $\sum_{i=1}^{n/2}\frac{n}{2i}$
>
> $$
> \begin{aligned}
> f &= \frac{n}{2} + \frac{n}{4} + \frac{n}{6} + ... + \frac{n}{2/n} \\
>   &= \frac{n}{2} × (1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{2/n}) \\
>   &= \frac{n}{2}(\ln{(\frac{n}{2}+1)}+C) =  \frac{n}{2}\ln{(\frac{n}{2}+1)}+\frac{nC}{2}
> \end{aligned}
> $$
>
> 所以 m 的值为$\frac{n}{2}\ln{(\frac{n}{2}+1)}+\frac{nC}{2}$，时间复杂度为$O(n\ln{n})$

### 1.11 有下列运行时间函数, 分别写出相应的大$O$表示的运算时间

1. $T_1(n)=1000$
2. $T_2(n)=n^2+1000n$
3. $T_3(n)=3n^3+100n^2+1$

> **解答：**
>
> 1. $O(n)$
> 2. $O(n^2)$
> 3. $O(n^3)$

### 1.12 给出下面两个算法的运算时间

```c
(1) for(i = 1; i <= n; i++)
        x = x + 1
(2) for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++)
            x = x + 1
```

> **解答：**
>
> (1)时间复杂度是$O(n)$, 一共需要赋值操作 1 次$i$和$n$次 x，共$n+1$次
>
> (2)时间复杂度是$O(n^2)$, 一共需要赋值操作$n^2$次 x，n 次$j$和 1 次$i$，一共是$n^2+n+1$次
