# 数据结构

## 定义

**定义一**：数据结构是 ADT 的物理实现。（《数据结构与算法分析》-Clifford A.Shaffer）

**定义二**：数据结构描述的是按照一定逻辑关系组织起来的待处理数据元素的表示及相关操作，涉及数据的**逻辑结构**、数据的**存储结构**和数据的**运算**。（《数据结构与算法》-张铭)

- 逻辑结构：具体问题中抽象出来的数据模型，反映了事物的组成结构和事物之间的逻辑关系

  常见的结构有线性结构、树形结构、图结构

- 存储结构：各种逻辑结构在计算机中的物理存储表示
  
  常用的基本存储映射方法有顺序方法、链式方法、索引方法和散列方法

- 运算

## 抽象数据类型(Abstract Data Type)

- 概念
  - 数据类型
    - 数据对象集
    - 数据集合相关联的操作集

  - 抽象：描述数据类型的方法不依赖于具体实现
    - 与存放数据的机器无关
    - 与数据存储的物理结构无关
    - 与实现操作的算法和编成语言无关

- 表示(D,R,P)

  ```c
  ADT 抽象数据类型名{
    数据对象D:<数据对象的定义>
    数据关系R:<数据关系的定义>
    基本操作P:<基本操作的定义>
  }
  ```

- 例子：“矩阵”的抽象数据类型定义
  - 类型名称：矩阵(Matrix)
  - 数据对象集：一个 M×N 的矩阵$A_{M×N}=(a_{ij})(i=1,...,M;j=1,...,N)$ M×N 个三元组<a,i,j>构成，其中 a 是矩阵元素的值，i 是元素所在的行号，j 是元素所在的列号。
  - 操作集：对任意矩阵 A、B、C ∈ Matrix，以及整数 i、j、M、N
    - Matrix Create(int M, int N)：返回一个 M×N 的空矩阵；
    - int GetMaxRow(Matrix A)：返回矩阵 A 的总行数；
    - int GetMaxCol(Maxtrix A)：返回矩阵 A 的总列数；
    - ......

## 算法(Algorithm)

1. 概念

   - 一个有限指令集
   - 接受一些输入（有些情况下不需要输入）
   - 产生输出
   - 一定在有限步骤后终止（有穷性）
   - 每一条指令必须（确定性）
     - 有充分明确的目标，不可以有歧义
     - 计算机能处理的范围之内
     - 描述不应依赖于任何一种计算机语言以及具体的实现手段

2. 常用分类

   - 穷举法：在一个可能存在可行状态的状态全集中依次遍历所有的元素，并判断是否为可行状态
   - 回溯法：一步一步向前试探，有多种选择时任意选择一种，只要可行就继续向前，一旦失败时就后退回来选择其他的可能性
   - 分治法和递归法：把一个规模较大的问题划分成相似的小问题，各个求解，再得到整个问题的解
   - 贪心法：试图通过局部最优解得到全局最优解
   - 动态规划：把大问题分解为若干小问题，通过求解子问题来得到原问题的解
   - 分支界限法：在表示问题空间的树上进行系统搜索时采用广度优先策略，同时利用最优解属性的上下界来控制搜索分支

3. 算法指标

   - 空间复杂度 S(n)：根据算法写成的程序在执行时占用存储单元的长度。
   - 时间复杂度 T(n)：根据算法写成的程序在执行时耗费时间的长度。

4. 复杂度的渐进表示
   - $T(n)=O(f(n))表示存在常数C>0,n_0>0使得当n≥n_0时有T(n)≤C·g(n)$
   - $T(n)=Ω(g(n))表示存在常数C>0,n_0>0使得当n≥n_0时有T(n)≥C·g(n)$
   - $T(n)=Θ(h(n))表示同时有T(n)=O(h(n))和T(n)=Ω(h(n))$

## 应用实

最大子列和问题：给定 N 个整数的序列${A_1,A_2,...,A_N}$，求函数$f(i,j)=max\{0,\sum_{k=i}^{j}A_k\}$的最大值。

- 算法 1：暴力法

  时间复杂度$O(n^3)$

  ```cpp
    int MaxSubseqSum1(int A[], int N){
        int ThisSum, MaxSum = 0;
        for(int i = 0; i < N; i++){         // i是子列左端位置
            for(int j = i; j < N; j++){     // j是子列右端的位置
                ThisSum = 0;                // A[i]到A[j]的子列和
                for(int k = i; k <= j; k++)
                    ThisSum += A[k];
                if(ThisSum > MaxSum)
                    MaxSum = ThisSum;       // 更新结果
            }
        }
        return MaxSum;
    }
  ```

- 算法 2：暴力法（优化)

  时间复杂度$O(n^2)$

  ```cpp
   int MaxSubseqSum2(int A[], int N){
       int ThisSum, MaxSum;
       for(int i = 0; i < N; i++){
           ThisSum = 0;
           for(int j = i; j < N; j++){
               ThisSum += A[j];            // 对于相同的i不同的j。只需要在j-1次循环的基础上累加1项即可
               if(ThisSum > MaxSum)
                   MaxSum = ThisSum;
           }
       }
       return MaxSum;
   }
  ```

- 算法 3：分而治之（略）

- 算法 4：在线处理

  时间复杂度 O(n)

  ```cpp
  int MaxSubseqSum4(int A[], int N){
      int ThisSum, MaxSum;
      ThisSum = MaxSum = 0;
      for(int i = 0; i < N; i++){
          ThisSum += A[i];                // 向右累加
          if(ThisSum > MaxSum)
              MaxSum = ThisSum;
          else if(ThisSum < 0)            // 当前子列和为负，则不可能使后面的部分增大
              ThisSum = 0;
      }
      return MaxSum;
  }
  ```
